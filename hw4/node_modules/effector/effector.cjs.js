function e(e,t){for(let r in e)t(e[r],r)}function t(e,t){e.forEach(t)}function r(e,t){if(!e)throw Error(t)}function a(e,t){let r=M(e).meta||{};Z={id:M(e).id,parent:Z,value:e,template:r.template||te(),sidRoot:r.sidRoot||Z&&Z.sidRoot,meta:r};try{return t()}finally{ee('region'),Z=O(Z)}}function n({node:e=[],from:r,source:a,parent:n=r||a,to:i,target:o,child:s=i||o,scope:l={},meta:d={},family:f={type:'regular'},regional:c}={}){let u=ne(n),p=ne(f.links),m=ne(f.owners),g=[];t(e,(e=>e&&H(g,e)));let h={id:X(),seq:g,next:ne(s),meta:d,scope:l,family:{type:f.type||"crosslink",links:p,owners:m}};return t(p,(e=>H($(e),h))),t(m,(e=>H(j(e),h))),t(u,(e=>H(e.next,h))),c&&Z&&ae(C(Z),[h]),h}function i(e,r,a){let n,i=Be,o=null,s=Fe;if(e.target&&(r=e.params,a=e.defer,n=e.meta,i='page'in e?e.page:i,e.stack&&(o=e.stack),s=I(e)||s,e=e.target),s&&Fe&&s!==Fe&&(Fe=null),Array.isArray(e))for(let t=0;t<e.length;t++)Ne('pure',i,M(e[t]),o,r[t],s,n);else Ne('pure',i,M(e),o,r,s,n);if(a&&!Ee)return;let l,d,f,c,u,p,m={isRoot:Ee,currentPage:Be,scope:Fe,isWatch:_e,isPure:Pe};Ee=0;e:for(;c=Ie();){let{idx:e,stack:r,type:a}=c;f=r.node,Be=u=r.page,Fe=I(r),u?p=u.reg:Fe&&(p=Fe.reg);let n=!!u,i=!!Fe,o={fail:0,scope:f.scope};l=d=0;for(let t=e;t<f.seq.length&&!l;t++){let s=f.seq[t];if(s.order){let{priority:n,barrierID:i}=s.order,o=i?u?`${u.fullID}_${i}`:i:0;if(t!==e||a!==n){i?Re.has(o)||(Re.add(o),qe(t,r,n,i)):qe(t,r,n);continue e}i&&Re.delete(o)}switch(s.type){case'mov':{let e,t=s.data;switch(t.from){case S:e=C(r);break;case"a":case'b':e=r[t.from];break;case"value":e=t.store;break;case"store":if(p&&!p[t.store.id])if(n){let e=We(u,t.store.id);r.page=u=e,e?p=e.reg:i?(Ve(Fe,t.store,0,1,t.softRead),p=Fe.reg):p=void 0}else i&&Ve(Fe,t.store,0,1,t.softRead);e=$e(p&&p[t.store.id]||t.store)}switch(t.to){case S:r.value=e;break;case"a":case'b':r[t.to]=e;break;case"store":He(u,Fe,f,t.target).current=e}break}case'compute':let e=s.data;if(e.fn){_e='watch'===N(f,'op'),Pe=e.pure;let t=e.safe?(0,e.fn)(C(r),o.scope,r):Je(o,e.fn,r);e.filter?d=!t:r.value=t,_e=m.isWatch,Pe=m.isPure}}l=o.fail||d}if(Ge&&Ge(r,o),!l){let e=C(r),a=I(r);if(t(f.next,(t=>{Ne('child',u,t,r,e,a)})),a){N(f,'needFxCounter')&&Ne('child',u,a.fxCount,r,e,a),N(f,'storeChange')&&Ne('child',u,a.storeChange,r,e,a),N(f,'warnSerialize')&&Ne('child',u,a.warnSerializeNode,r,e,a);let n=a.additionalLinks[f.id];n&&t(n,(t=>{Ne('child',u,t,r,e,a)}))}}}Ee=m.isRoot,Be=m.currentPage,Fe=I(m)}function o(t,r="combine"){let a=r+'(',n='',i=0;return e(t,(e=>{i<25&&(null!=e&&(a+=n,a+=R(e)?D(e).fullName:e.toString()),i+=1,n=', ')})),a+')'}function s(e,t){let r,a,n=e;if(t){let n=D(t);0===e.length?(r=n.path,a=n.fullName):(r=n.path.concat([e]),a=0===n.fullName.length?e:n.fullName+'/'+e)}else r=0===e.length?[]:[e],a=e;return{shortName:n,fullName:a,path:r}}function l(e,t){let r=t?e:e[0];le(r);let a=r.or,n=r.and;if(n){let r=t?n:n[0];if(ie(r)&&'and'in r){let r=l(n,t);e=r[0],a={...a,...r[1]}}else e=n}return[e,a]}function d(e,...t){let r=te();if(r){let a=r.handlers[e];if(a)return a(r,...t)}}function f(e,t){let r=Ke({or:t,and:'string'==typeof e?{name:e}:e}),a=(e,...t)=>(U(!N(a,'derived'),'call of derived event','createEvent'),U(!Pe,'unit call from pure function','operators like sample'),Be?((e,t,r,a)=>{let n=Be,i=null;if(t)for(i=Be;i&&i.template!==t;)i=O(i);Te(i);let o=e.create(r,a);return Te(n),o})(a,o,e,t):a.create(e,t)),o=te(),s=Object.assign(a,{graphite:n({meta:nt(r.actualOp||"event",a,r),regional:1}),create:e=>(i({target:a,params:e,scope:Fe}),e),watch:e=>rt(a,e),map:e=>ot(a,w,e,[we()]),filter:e=>ot(a,"filter",e.fn?e:e.fn,[we(me,1)]),filterMap:e=>ot(a,'filterMap',e,[we(),xe((e=>!se(e)),1)]),prepend(e){let t=f('* \u2192 '+a.shortName,{parent:O(a)});return d('eventPrepend',M(t)),tt(t,a,[we()],'prepend',e),at(a,t),t}});return null!=r&&r.domain&&r.domain.hooks.event(s),q(s,'id',s.graphite.id),ee(s.graphite),s}function c(e,a,n,i){return fe(n,a,'first argument'),r(oe(i),'second argument should be a function'),U(!N(e,'derived'),`${a} in derived store`,`${a} in store created via createStore`),t(Array.isArray(n)?n:[n],(t=>{e.off(t),A(e).set(t,et(st(t,e,'on',pe,i)))})),e}function u(e,a){let o=Ke(a),s=Me(e),l=f({named:'updates',derived:1});d('storeBase',s);let p=s.id,m={subscribers:new Map,updates:l,defaultState:e,stateRef:s,getState(){let e,t=s;if(Be){let t=Be;for(;t&&!t.reg[p];)t=O(t);t&&(e=t)}return!e&&Fe&&(Ve(Fe,s,1),e=Fe),e&&(t=e.reg[p]),$e(t)},setState:e=>i({target:m,params:e,defer:1,scope:Fe}),reset:(...e)=>(t(e,(e=>c(m,'.reset',e,(()=>m.defaultState)))),m),on:(e,t)=>c(m,'.on',e,t),off(e){let t=A(m).get(e);return t&&(t(),A(m).delete(e)),m},map(e,t){let r,a;ie(e)&&(r=e,e=e.fn),U(se(t),'second argument of store.map','updateFilter');let n=m.getState();te()?a=null:se(n)||(a=e(n,t));let i=u(a,{name:`${m.shortName} \u2192 *`,derived:1,and:r}),o=st(m,i,w,ue,e);return je(z(i),{type:w,fn:e,from:s}),z(i).noInit=1,d('storeMap',s,o),i},watch(e,t){if(!t||!R(e)){let t=rt(m,e);return d('storeWatch',s,e)||e(m.getState()),t}return r(oe(t),'second argument should be a function'),e.watch((e=>t(m.getState(),e)))}},g=nt("store",m,o),h=m.defaultConfig.updateFilter;m.graphite=n({scope:{state:s,fn:h},node:[xe(((e,t,r)=>(r.scope&&!r.scope.reg[s.id]&&(r.b=1),e))),ke(s),xe(((e,t,{a:r,b:a})=>!se(e)&&(e!==r||a)),1),h&&we(ue,1),ye({from:S,target:s})],child:l,meta:{...g,defaultState:e},regional:1}),q(m,'id',m.graphite.id),q(m,'rootStateRefId',p);let y=N(m,'serialize'),b=N(m,'derived'),v='ignore'===y,x=N(m,'sid');return x&&(q(m,'storeChange',1),s.sid=x),x||v||b||q(m,'warnSerialize',1),r(b||!se(e),"current state can't be undefined, use null instead"),ae(m,[l]),null!=o&&o.domain&&o.domain.hooks.store(m),b||(m.reinit=f({named:'reinit'}),m.reset(m.reinit)),s.meta=m.graphite.meta,ee(m.graphite),m}function p(...e){let t,a,n;[e,n]=l(e);let i,o,s,d=e[e.length-1];if(oe(d)?(a=e.slice(0,-1),t=d):a=e,1===a.length){let e=a[0];E(e)||(i=e,o=1)}if(!o&&(i=a,t)){s=1;let e=t;t=t=>e(...t)}return r(ie(i),'shape should be an object'),lt(Array.isArray(i),!s,i,n,t)}function m(){let e={};return e.req=new Promise(((t,r)=>{e.rs=t,e.rj=r})),e.req.catch((()=>{})),e}function g(e,t={}){let a=Ke(oe(e)?{handler:e}:e,t),o=f(oe(e)?{handler:e}:e,{...t,actualOp:"effect"}),s=M(o);q(s,'op',o.kind="effect"),o.use=e=>(r(oe(e),'.use argument should be a function'),h.scope.handler=e,o),o.use.getCurrent=()=>h.scope.handler;let l=o.finally=f({named:'finally',derived:1}),d=o.done=l.filterMap({named:'done',fn({status:e,params:t,result:r}){if('done'===e)return{params:t,result:r}}}),c=o.fail=l.filterMap({named:'fail',fn({status:e,params:t,error:r}){if('fail'===e)return{params:t,error:r}}}),p=o.doneData=d.map({named:'doneData',fn:({result:e})=>e}),g=o.failData=c.map({named:'failData',fn:({error:e})=>e}),h=n({scope:{handler:o.defaultConfig.handler||(()=>r(0,`no handler used in ${o.getType()}`))},node:[xe(((e,t,r)=>{let a=t.handler,n=I(r);if(n){let e=n.handlers.unitMap.get(o)||n.handlers.sidMap[o.sid];e&&(a=e)}return e.handler=a,e}),0,1),xe((({params:e,req:t,handler:r,args:a=[e]},n,i)=>{let o=ft(i),s=ct(e,t,1,l,i,o),d=ct(e,t,0,l,i,o),[f,c]=dt(r,d,a);f&&(ie(c)&&oe(c.then)?c.then(s,d):s(c))}),0,1)],meta:{op:'fx',fx:'runner'}});s.scope.runner=h,H(s.seq,xe(((e,{runner:t},r)=>{let a=O(r)?{params:e,req:{rs(e){},rj(e){}}}:e;return r.meta||(r.meta={fxID:Y()}),i({target:t,params:a,defer:1,scope:I(r),meta:r.meta}),a.params}),0,1)),o.create=e=>{let t=m(),r={params:e,req:t};if(Fe&&!_e){let e=Fe;t.req.finally((()=>{Le(e)})).catch((()=>{}))}return i({target:o,params:r,scope:Fe}),t.req};let y=o.inFlight=u(0,{serialize:'ignore',named:(N(o,'name')||o.graphite.id)+'.inFlight'}).on(o,(e=>e+1)).on(l,(e=>e-1)).map({fn:e=>e,named:'inFlight'});q(l,'needFxCounter','dec'),q(o,'needFxCounter',1);let b=o.pending=y.map({fn:e=>e>0,named:'pending'});return ae(o,[l,d,c,p,g,b,y]),null!=a&&a.domain&&a.domain.hooks.effect(o),o}function h(e,t){fe(e,'merge','first argument');let r=f({name:o(e,'merge'),derived:1,and:t});return tt(e,r,[],'merge'),r}function y(e,a){let n=0;return t(pt,(t=>{t in e&&(r(null!=e[t],mt(a,t)),n=1)})),n}function b(e,r,a){let n=[];(function e(i){W(n,i)||(H(n,i),"store"===N(i,'op')&&(a||N(i,'sid'))&&r(i,N(i,'sid')),t(i.next,e),t($(i),e),t(j(i),e))})(e)}function v(e,a){let n=Array.isArray(e)?new Map(e):e,i=new Map,o=0;if(n instanceof Map){let e={};return t(n,((t,n)=>{r(R(n),'Map key should be a unit'),a&&a(n,t),n.sid&&(n.sid in e&&(o=1),e[n.sid]=t),i.set(n,t)})),{sidMap:e,unitMap:i,hasSidDoubles:o}}return{sidMap:n,unitMap:i}}function x(e){let t=()=>e();return t.unsubscribe=()=>e(),t}Object.defineProperty(exports,'__esModule',{value:1});let k='undefined'!=typeof Symbol&&Symbol.observable||'@@observable',w='map',S='stack',M=e=>e.graphite||e,$=e=>e.family.owners,j=e=>e.family.links,z=e=>e.stateRef,C=e=>e.value,A=e=>e.subscribers,O=e=>e.parent,I=e=>e.scope,N=(e,t)=>M(e).meta[t],q=(e,t,r)=>M(e).meta[t]=r,D=e=>e.compositeName,R=e=>(oe(e)||ie(e))&&'kind'in e;const F=e=>t=>R(t)&&t.kind===e;let E=F("store"),_=F("event"),P=F("effect"),B=F("domain"),L=F("scope");var T={__proto__:null,unit:R,store:E,event:_,effect:P,domain:B,scope:L,attached:e=>P(e)&&1==N(e,'attached')};let W=(e,t)=>e.includes(t),G=(e,t)=>{let r=e.indexOf(t);-1!==r&&e.splice(r,1)},H=(e,t)=>e.push(t),U=(e,t,r)=>!e&&console.error(`${t} is deprecated${r?`, use ${r} instead`:''}`);const V=()=>{let e=0;return()=>""+ ++e};let J,K=V(),Q=V(),X=V(),Y=V(),Z=null,ee=e=>{J&&J(e,Z)},te=()=>Z&&Z.template,re=e=>(e&&Z&&Z.sidRoot&&(e=`${Z.sidRoot}|${e}`),e),ae=(e,r)=>{let a=M(e);t(r,(e=>{let t=M(e);"domain"!==a.family.type&&(t.family.type="crosslink"),H($(t),a),H(j(a),t)}))},ne=(e=[])=>(Array.isArray(e)?e:[e]).flat().map(M),ie=e=>'object'==typeof e&&null!==e,oe=e=>'function'==typeof e,se=e=>void 0===e,le=e=>r(ie(e)||oe(e),'expect first argument be an object');const de=(e,t,a,n)=>r(!(!ie(e)&&!oe(e)||!('family'in e)&&!('graphite'in e)),`${t}: expect ${a} to be a unit (store, event or effect)${n}`);let fe=(e,r,a)=>{Array.isArray(e)?t(e,((e,t)=>de(e,r,`${t} item of ${a}`,''))):de(e,r,a,' or array of units')},ce=(e,r,a="target")=>t(ne(r),(t=>U(!N(t,'derived'),`${e}: derived unit in "${a}"`,"createEvent/createStore"))),ue=(e,{fn:t},{a:r})=>t(e,r),pe=(e,{fn:t},{a:r})=>t(r,e),me=(e,{fn:t})=>t(e);const ge=(e,t,r,a)=>{let n={id:Q(),type:e,data:t};return r&&(n.order={priority:r},a&&(n.order.barrierID=++he)),n};let he=0,ye=({from:e="store",store:t,target:r,to:a=(r?"store":S),batch:n,priority:i})=>ge('mov',{from:e,store:t,to:a,target:r},i,n),be=({fn:e,batch:t,priority:r,safe:a=0,filter:n=0,pure:i=0})=>ge('compute',{fn:e,safe:a,filter:n,pure:i},r,t),ve=({fn:e})=>be({fn:e,priority:"effect"}),xe=(e,t,r)=>be({fn:e,safe:1,filter:t,priority:r&&"effect"}),ke=(e,t,r)=>ye({store:e,to:t?S:"a",priority:r&&"sampler",batch:1}),we=(e=me,t)=>be({fn:e,pure:1,filter:t}),Se={mov:ye,compute:be,filter:({fn:e,pure:t})=>be({fn:e,filter:1,pure:t}),run:ve},Me=e=>({id:Q(),current:e}),$e=({current:e})=>e,je=(e,t)=>{e.before||(e.before=[]),H(e.before,t)},ze=null;const Ce=(e,t)=>{if(!e)return t;if(!t)return e;let r;return(e.v.type===t.v.type&&e.v.id>t.v.id||De(e.v.type)>De(t.v.type))&&(r=e,e=t,t=r),r=Ce(e.r,t),e.r=e.l,e.l=r,e},Ae=[];let Oe=0;for(;Oe<6;)H(Ae,{first:null,last:null,size:0}),Oe+=1;const Ie=()=>{for(let e=0;e<6;e++){let t=Ae[e];if(t.size>0){if(3===e||4===e){t.size-=1;let e=ze.v;return ze=Ce(ze.l,ze.r),e}1===t.size&&(t.last=null);let r=t.first;return t.first=r.r,t.size-=1,r.v}}},Ne=(e,t,r,a,n,i,o)=>qe(0,{a:null,b:null,node:r,parent:a,value:n,page:t,scope:i,meta:o},e),qe=(e,t,r,a=0)=>{let n=De(r),i=Ae[n],o={v:{idx:e,stack:t,type:r,id:a},l:null,r:null};3===n||4===n?ze=Ce(ze,o):(0===i.size?i.first=o:i.last.r=o,i.last=o),i.size+=1},De=e=>{switch(e){case'child':return 0;case'pure':return 1;case'read':return 2;case"barrier":return 3;case"sampler":return 4;case"effect":return 5;default:return-1}},Re=new Set;let Fe,Ee=1,_e=0,Pe=0,Be=null,Le=e=>{Fe=e},Te=e=>{Be=e};const We=(e,t)=>{if(e){for(;e&&!e.reg[t];)e=O(e);if(e)return e}return null};let Ge,He=(e,t,r,a,n)=>{let i=We(e,a.id);return i?i.reg[a.id]:t?(Ve(t,a,n),t.reg[a.id]):a};const Ue=e=>e;let Ve=(e,r,a,n,i)=>{var o;let s=e.reg;if(s[r.id])return;let l=r.sid,d=null==r||null===(o=r.meta)||void 0===o?void 0:o.serialize,f=e.fromSerialize&&'ignore'!==d&&(null==d?void 0:d.read)||Ue,c={id:r.id,current:r.current,meta:r.meta};if(c.id in e.values.idMap)c.current=e.values.idMap[c.id];else if(l&&l in e.values.sidMap&&!(l in e.sidIdMap))c.current=f(e.values.sidMap[l]);else if(r.before&&!i){let i=0,o=a||!r.noInit||n;t(r.before,(t=>{switch(t.type){case w:{let r=t.from;if(r||t.fn){r&&Ve(e,r,a,n);let i=r&&s[r.id].current;o&&(c.current=t.fn?t.fn(i):i)}break}case'field':i||(i=1,c.current=Array.isArray(c.current)?[...c.current]:{...c.current}),Ve(e,t.from,a,n),o&&(c.current[t.field]=s[s[t.from.id].id].current)}}))}l&&(e.sidIdMap[l]=r.id),s[r.id]=c};const Je=(e,t,r)=>{try{return t(C(r),e.scope,r)}catch(t){console.error(t),e.fail=1,e.failReason=t}};let Ke=(t,r={})=>(ie(t)&&(Ke(t.or,r),e(t,((e,t)=>{se(e)||'or'===t||'and'===t||(r[t]=e)})),Ke(t.and,r)),r);const Qe=(e,t)=>{G(e.next,t),G($(e),t),G(j(e),t)},Xe=(e,t,r)=>{let a;e.next.length=0,e.seq.length=0,e.scope=null;let n=j(e);for(;a=n.pop();)Qe(a,e),(t||r&&'sample'!==N(e,'op')||"crosslink"===a.family.type)&&Xe(a,t,'on'!==N(a,'op')&&r);for(n=$(e);a=n.pop();)Qe(a,e),r&&"crosslink"===a.family.type&&Xe(a,t,'on'!==N(a,'op')&&r)},Ye=e=>e.clear();let Ze=(e,{deep:t}={})=>{let r=0;if(e.ownerSet&&e.ownerSet.delete(e),E(e))Ye(A(e));else if(B(e)){r=1;let t=e.history;Ye(t.events),Ye(t.effects),Ye(t.stores),Ye(t.domains)}Xe(M(e),!!t,r)},et=e=>{let t=()=>Ze(e);return t.unsubscribe=t,t},tt=(e,t,r,a,i)=>n({node:r,parent:e,child:t,scope:{fn:i},meta:{op:a},family:{owners:[e,t],links:t},regional:1}),rt=(e,t)=>(r(oe(t),'.watch argument should be a function'),et(n({scope:{fn:t},node:[ve({fn:me})],parent:e,meta:{op:'watch'},family:{owners:e},regional:1}))),at=(e,t,r="event")=>{O(e)&&O(e).hooks[r](t)},nt=(e,t,r)=>{let a=Ke(r),n="domain"===e,i=K(),{sid:o=null,named:l=null,domain:d=null,parent:f=d}=a,c=l||a.name||(n?'':i),u=s(c,f),p={op:t.kind=e,name:t.shortName=c,sid:t.sid=re(o),named:l,unitId:t.id=i,serialize:a.serialize,derived:a.derived,config:a};if(t.parent=f,t.compositeName=u,t.defaultConfig=a,t.thru=e=>(U(0,'thru','js pipe'),e(t)),t.getType=()=>u.fullName,!n){t.subscribe=e=>(le(e),t.watch(oe(e)?e:t=>e.next&&e.next(t))),t[k]=()=>t;let e=te();e&&(p.nativeTemplate=e)}return p};const ot=(e,t,r,a)=>{let n;ie(r)&&(n=r,r=r.fn);let i=f({name:`${e.shortName} \u2192 *`,derived:1,and:n});return tt(e,i,a,t,r),i},st=(e,t,r,a,n)=>{let i=z(t),o=ye({store:i,to:"a",priority:'read'});r===w&&(o.data.softRead=1);let s=[o,we(a)];return d('storeOnMap',i,s,E(e)&&z(e)),tt(e,t,s,r,n)},lt=(t,a,n,i,s)=>{let l=t?e=>[...e]:e=>({...e}),f=t?[]:{},c=l(f),p=Me(c),m=Me(1);p.type=t?'list':'shape',p.noInit=1,d('combineBase',p,m);let g=u(c,{name:o(n),derived:1,and:i}),h=z(g);h.noInit=1,q(g,'isCombine',1);let y=ke(p);y.order={priority:'barrier'};let b=ye({store:h,to:'b',priority:'read'});b.data.softRead=1;let v=[xe(((e,t,r)=>(r.scope&&!r.scope.reg[p.id]&&(r.c=1),e))),y,ye({store:m,to:'b'}),xe(((e,{key:t},r)=>{if(r.c||e!==r.a[t])return a&&r.b&&(r.a=l(r.a)),r.a[t]=e,1}),1),ye({from:"a",target:p}),ye({from:"value",store:0,target:m}),ye({from:"value",store:1,target:m,priority:"barrier",batch:1}),ke(p,1),s&&we(),b];return e(n,((e,t)=>{if(!E(e))return r(!R(e)&&!se(e),`combine expects a store in a field ${t}`),void(c[t]=f[t]=e);f[t]=e.defaultState,c[t]=e.getState();let a=tt(e,g,v,'combine',s);a.scope.key=t;let n=z(e);je(p,{type:'field',field:t,from:n}),d('combineField',n,a)})),g.defaultShape=n,je(h,{type:w,from:p,fn:s}),te()||(g.defaultState=s?h.current=s(c):f),g};let dt=(e,t,r)=>{try{return[1,e(...r)]}catch(e){return t(e),[0,null]}},ft=e=>{let t=I(e),r={ref:t};return t&&H(t.activeEffects,r),r},ct=(e,t,r,a,n,o)=>s=>{o.ref&&G(o.ref.activeEffects,o),i({target:[a,ut],params:[r?{status:'done',params:e,result:s}:{status:'fail',params:e,error:s},{value:s,fn:r?t.rs:t.rj}],defer:1,page:n.page,scope:o.ref,meta:n.meta})};const ut=n({node:[ve({fn:({fn:e,value:t})=>e(t)})],meta:{op:'fx',fx:'sidechain'}}),pt=['source','clock','target'],mt=(e,t)=>e+`: ${t} should be defined`;let gt=(e,t,a,n,i,o,s,l,c,m,g,y)=>{let b=!!i;r(!se(a)||!se(t),mt(e,'either source or clock'));let v=0;se(a)?v=1:R(a)||(a=p(a)),se(t)?t=a:(fe(t,e,'clock'),Array.isArray(t)&&(t=h(t))),v&&(a=t),l||s||(s=a.shortName);let x='none';(g||n)&&(R(n)?x='unit':(r(oe(n),'`filter` should be function or unit'),x='fn')),i?(fe(i,e,'target'),ce(e,i)):'none'===x&&m&&E(a)&&E(t)?i=u(o?o($e(z(a)),$e(z(t))):$e(z(a)),{name:s,sid:y,or:l}):(i=f({name:s,derived:1,or:l}),d('sampleTarget',M(i)));let k=Me(),w=[];if('unit'===x){let[r,a]=yt(n,i,t,k,e);w=[...ht(a),...ht(r)]}let[$,j]=yt(a,i,t,k,e),C=tt(t,i,[d('sampleSourceLoader'),ye({from:S,target:k}),...ht(j),ke($,1,c),...w,ke(k),'fn'===x&&we(((e,t,{a:r})=>n(e,r)),1),o&&we(ue),d('sampleSourceUpward',b)],e,o);return ae(a,[C]),Object.assign(C.meta,l,{joint:1}),i};const ht=e=>[ke(e),xe(((e,t,{a:r})=>r),1)],yt=(e,t,r,a,i)=>{let o=E(e),s=o?z(e):Me(),l=Me(o);return o||n({parent:e,node:[ye({from:S,target:s}),ye({from:"value",store:1,target:l})],family:{owners:[e,t,r],links:t},meta:{op:i},regional:1}),d('sampleSource',l,s,a),[s,l]},bt=(e,t,r,a)=>{let n=e[t];n&&i({target:n,params:Array.isArray(n)?n.map((()=>r)):r,defer:1,stack:a})},vt=e=>e;exports.allSettled=(e,{scope:t,params:r}={})=>{if(!R(e))return Promise.reject(new Error('first argument should be unit'));if(!(P(e)||_(e)||E(e)||L(e)))return Promise.reject(new Error('first argument accepts only effects, events, stores or scopes'));L(e)&&(t=e);let a=m();a.parentFork=Fe;let{fxCount:n}=t;H(n.scope.defers,a);let o=[],s=[];return L(e)||(H(o,e),H(s,P(e)?{params:r,req:{rs(e){a.value={status:'done',value:e}},rj(e){a.value={status:'fail',value:e}}}}:r)),H(o,n),H(s,null),i({target:o,params:s,scope:t}),a.req},exports.attach=e=>{let t;[e,t]=l(e,1);let{source:r,effect:a,mapParams:n}=e,o=g(e,t);q(o,'attached',1);let d,{runner:f}=M(o).scope,c=xe(((e,t,a)=>{let s,{params:l,req:d,handler:f}=e,c=o.finally,u=ft(a),p=ct(l,d,0,c,a,u),m=a.a,g=P(f),h=1;if(n?[h,s]=dt(n,p,[l,m]):s=r&&g?m:l,h){if(!g)return e.args=[m,s],1;i({target:f,params:{params:s,req:{rs:ct(l,d,1,c,a,u),rj:p}},page:a.page,defer:1,meta:a.meta})}}),1,1);if(r){let e;E(r)?(e=r,ae(e,[o])):(e=p(r),ae(o,[e])),d=[ke(z(e)),c]}else d=[c];f.seq.splice(1,0,...d),o.use(a);let u=O(a);return u&&(Object.assign(D(o),s(o.shortName,u)),o.defaultConfig.parent=u),at(a,o,"effect"),o},exports.clearNode=Ze,exports.combine=p,exports.createApi=(...t)=>{let[[r,a],n]=l(t),i={};return e(a,((e,t)=>{let a=i[t]=f(t,{parent:O(r),config:n});r.on(a,e),at(r,a)})),i},exports.createDomain=function r(a,o){let s=Ke({or:o,and:'string'==typeof a?{name:a}:a}),l=n({family:{type:"domain"},regional:1,parent:(null==s?void 0:s.domain)||(null==s?void 0:s.parent)}),d={history:{},graphite:l,hooks:{}};l.meta=nt("domain",d,{parent:(null==s?void 0:s.domain)||(null==s?void 0:s.parent),or:s}),e({Event:f,Effect:g,Store:u,Domain:r},((e,r)=>{let a=r.toLowerCase(),n=f({named:`on${r}`});d.hooks[a]=n;let o=new Set;d.history[`${a}s`]=o,n.create=e=>(i(n,e),e),H(M(n).seq,xe(((e,t,r)=>(r.scope=null,e)))),n.watch((e=>{ae(d,[e]),o.add(e),e.ownerSet||(e.ownerSet=o),O(e)||(e.parent=d)})),ae(d,[n]),d[`onCreate${r}`]=e=>(t(o,e),n.watch(e)),d[`create${r}`]=d[a]=(t,r)=>{let a=Ke({and:r,or:t});return null!=a&&a.domain?e(t,r):n(e(t,{parent:d,or:a}))}}));let c=O(d);return c&&e(d.hooks,((e,t)=>tt(e,c.hooks[t]))),null!=s&&s.domain&&s.domain.hooks.domain(d),d},exports.createEffect=g,exports.createEvent=f,exports.createNode=n,exports.createStore=u,exports.createStoreObject=(...e)=>(U(0,'createStoreObject','combine'),p(...e)),exports.createWatch=({unit:e,fn:t,scope:r})=>{let a=[Se.run({fn:e=>t(e)})];if(r){let t=n({node:a}),i=e.graphite.id,o=r.additionalLinks,s=o[i]||[];return o[i]=s,s.push(t),x((()=>{let e=s.indexOf(t);-1!==e&&s.splice(e,1),Ze(t)}))}{let t=n({node:a,parent:[e],family:{owners:e}});return x((()=>{Ze(t)}))}},exports.fork=(e,a)=>{let i,o=e;B(e)&&(i=e,o=a);let s=(e=>{let r=n({scope:{defers:[],inFlight:0,fxID:0},node:[xe(((e,t,r)=>{O(r)?'dec'===N(O(r).node,'needFxCounter')?t.inFlight-=1:(t.inFlight+=1,t.fxID+=1):t.fxID+=1})),be({priority:"sampler",batch:1}),xe(((e,r)=>{let{defers:a,fxID:n}=r;r.inFlight>0||0===a.length||Promise.resolve().then((()=>{r.fxID===n&&t(a.splice(0,a.length),(e=>{Le(e.parentFork),e.rs(e.value)}))}))}),0,1)]}),a=n({node:[xe(((e,t,r)=>{let a=O(r);if(a){let t=a.node;if(!N(t,'isCombine')||O(a)&&'combine'!==N(O(a).node,'op')){let a=I(r),n=t.scope.state.id,i=N(t,'sid');a.sidIdMap[i]=n,a.values.sidMap[i]=e;let o=N(t,'serialize');o&&a.sidSerializeSettings.set(i,'ignore'===o?{ignore:1}:{ignore:0,write:o.write})}}}))]}),i=n({node:[xe(((e,t,r)=>{let a=I(r);if(a){let e=O(r);e&&(!N(e.node,'isCombine')||O(e)&&'combine'!==N(O(e).node,'op'))&&(a.warnSerialize=1)}}))]}),o={cloneOf:e,reg:{},values:{sidMap:{},idMap:{}},sidIdMap:{},sidSerializeSettings:new Map,getState(e){if('current'in e)return He(Be,o,null,e).current;let t=M(e);return He(Be,o,t,t.scope.state,1).current},kind:"scope",graphite:n({family:{type:"domain",links:[r,a,i]},meta:{unit:'fork'},scope:{forkInFlightCounter:r}}),additionalLinks:{},handlers:{sidMap:{},unitMap:new Map},fxCount:r,storeChange:a,warnSerializeNode:i,activeEffects:[]};return o})(i);if(o){let e=o.scope;if(e){let r=e.activeEffects;e.activeEffects=[],s.activeEffects=r,t(r,(e=>e.ref=s))}if(o.values){let{sidMap:e,unitMap:a,hasSidDoubles:n}=v(o.values,(e=>r(E(e),'Values map can contain only stores as keys')));Object.assign(s.values.sidMap,e),t(a,((e,t)=>{s.values.idMap[t.stateRef.id]=e})),s.fromSerialize=!(Array.isArray(o.values)||o.values instanceof Map),s.hasSidDoubles=n}o.handlers&&(s.handlers=v(o.handlers,(e=>r(P(e),"Handlers map can contain only effects as keys"))))}return s},exports.forward=e=>{let t='forward',[{from:r,to:a},i]=l(e,1);return fe(r,t,'"from"'),fe(a,t,'"to"'),ce(t,a,'to'),et(n({parent:r,child:a,meta:{op:t,config:i},family:{},regional:1}))},exports.fromObservable=e=>{le(e);let t=k in e?e[k]():e;r(t.subscribe,'expect observable to have .subscribe');let a=f(),n=et(a);return t.subscribe({next:a,error:n,complete:n}),a},exports.guard=(...e)=>{let[[t,r],a]=l(e);return r||(r=t,t=r.source),y(r,'guard'),gt('guard',r.clock,t,r.filter,r.target,null,r.name,a,!r.greedy,0,1)},exports.hydrate=(e,{values:a})=>{r(ie(a),'values property should be an object');let{sidMap:n,unitMap:o}=v(a),s=Object.getOwnPropertyNames(n),l={};t(o,((e,t)=>{l[t.stateRef.id]=t}));let d,f,c,u=[],p=[];L(e)?(d=e,c=1,r(d.cloneOf,'scope should be created from domain'),f=M(d.cloneOf)):B(e)?f=M(e):r(0,'first argument of hydrate should be domain or scope'),b(f,((e,t)=>{if(t&&W(s,t)){H(u,e);let r=N(e,'serialize');r&&'ignore'!==r&&(n[t]=r.read(n[t])),H(p,n[t])}else e.scope.state.id in l&&(H(u,e),H(p,o.get(l[e.scope.state.id])))}),1),i({target:u,params:p,scope:d}),c&&Object.assign(d.values.sidMap,n)},exports.is=T,exports.launch=i,exports.merge=h,exports.restore=(t,r,a)=>{if(E(t))return U(0,'restore($store)'),t;if(_(t)||P(t)){let e=O(t),n=u(r,{parent:e,name:t.shortName,and:a});return tt(P(t)?t.doneData:t,n),e&&e.hooks.store(n),n}let n=Array.isArray(t)?[]:{};return e(t,((e,t)=>n[t]=E(e)?e:u(e,{name:t}))),n},exports.sample=(...e)=>{let t,r,a,n,[[i,o,s],d]=l(e),f=1;return se(o)&&ie(i)&&y(i,"sample")&&(o=i.clock,s=i.fn,f=!i.greedy,n=i.filter,t=i.target,r=i.name,a=i.sid,i=i.source),gt("sample",o,i,n,t,s,r,d,f,1,0,a)},exports.scopeBind=(e,{scope:t,safe:a}={})=>{r(t||Fe||a,'scopeBind cannot be called outside of forked .watch');let n=t||Fe;return P(e)?t=>{let r=m();return i({target:e,params:{params:t,req:r},scope:n}),r.req}:t=>(i({target:e,params:t,scope:n}),t)},exports.serialize=(t,a={})=>{t.warnSerialize&&console.error('There is a store without sid in this scope, its value is omitted'),r(!t.hasSidDoubles,'duplicate sid found in this scope');let n=a.ignore?a.ignore.map((({sid:e})=>e)):[],i={};return e(t.values.sidMap,((e,r)=>{var a;if(W(n,r))return;let o=t.sidIdMap[r],s=null!==(a=t.sidSerializeSettings.get(r))&&void 0!==a?a:{ignore:0,write:vt};s.ignore||(i[r]=(0,s.write)(o&&o in t.reg?t.reg[o].current:e))})),'onlyChanges'in a&&!a.onlyChanges&&(r(t.cloneOf,'scope should be created from domain'),b(M(t.cloneOf),((e,r)=>{r in i||W(n,r)||N(e,'isCombine')||'ignore'===N(e,'serialize')||(i[r]=t.getState(e))}))),i},exports.setGraphInspector=e=>{J=e},exports.setInspector=e=>{Ge=e},exports.setStoreName=(e,t)=>{e.shortName=t,Object.assign(D(e),s(t,O(e)))},exports.split=(...t)=>{let a,i,o='split',[[s,c],u]=l(t),p=!c;p&&(a=s.cases,c=s.match,i=s.clock,s=s.source);let m=E(c),g=!R(c)&&oe(c),h=!m&&!g&&ie(c);r(R(s),'source must be a unit'),a||(a={}),p?e(a,((e,t)=>ce(o,e,`cases.${t}`))):(r(h,'match should be an object'),e(c,((e,t)=>a[t]=f({derived:1,named:`cases.${t}`,and:u}))),a.__=f({derived:1,named:'cases.__',and:u}));let y,b=new Set([].concat(s,i||[],Object.values(a))),v=Object.keys(m||g?a:c);if(m||g)m&&b.add(c),y=[m&&ke(z(c),0,1),be({safe:m,filter:1,pure:!m,fn(e,t,r){let a=String(m?r.a:c(e));bt(t,W(v,a)?a:'__',e,r)}})];else if(h){let t=Me({});t.type='shape';let r,a=[];e(c,((e,n)=>{if(R(e)){r=1,H(a,n),b.add(e);let i=tt(e,[],[ke(t),xe(((e,t,{a:r})=>r[n]=e))]);if(E(e)){t.current[n]=e.getState();let r=z(e);je(t,{from:r,field:n,type:'field'}),d('splitMatchStore',r,i)}}})),r&&d('splitBase',t),y=[r&&ke(t,0,1),we(((e,t,r)=>{for(let n=0;n<v.length;n++){let i=v[n];if(W(a,i)?r.a[i]:c[i](e))return void bt(t,i,e,r)}bt(t,'__',e,r)}),1)]}else r(0,'expect match to be unit, function or object');let x=n({meta:{op:o},parent:i?[]:s,scope:a,node:y,family:{owners:Array.from(b)},regional:1});if(i&&gt(o,i,s,null,x,null,o,u,0,0,0),!p)return a},exports.step=Se,exports.version="22.8.7",exports.withFactory=({sid:e,name:t,loc:r,method:i,fn:o})=>a(n({meta:{sidRoot:re(e),sid:e,name:t,loc:r,method:i,type:'factory'}}),o),exports.withRegion=a;
//# sourceMappingURL=effector.cjs.js.map
