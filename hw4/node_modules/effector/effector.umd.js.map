{"version":3,"file":"effector.umd.js","sources":["../../src/effector/collection.ts","../../src/effector/throw.ts","../../src/effector/region.ts","../../src/effector/createNode.ts","../../src/effector/kernel.ts","../../src/effector/naming.ts","../../src/effector/config.ts","../../src/effector/template.ts","../../src/effector/createUnit.ts","../../src/effector/tag.ts","../../src/effector/combine.ts","../../src/effector/defer.ts","../../src/effector/createEffect.ts","../../src/effector/merge.ts","../../src/effector/sample.ts","../../src/effector/fork/util.ts","../../src/effector/createWatch.ts","../../src/effector/observable.ts","../../src/effector/getter.ts","../../src/effector/validate.ts","../../src/effector/id.ts","../../src/effector/own.ts","../../src/effector/is.ts","../../src/effector/caller.ts","../../src/effector/step.ts","../../src/effector/stateRef.ts","../../src/effector/clearNode.ts","../../src/effector/subscription.ts","../../src/effector/forward.ts","../../src/effector/watch.ts","../../src/effector/split.ts","../../src/effector/fork/serialize.ts","../../src/effector/fork/allSettled.ts","../../src/effector/attach.ts","../../src/effector/createApi.ts","../../src/effector/createDomain.ts","../../src/effector/fork/fork.ts","../../src/effector/fork/createScope.ts","../../src/effector/fromObservable.ts","../../src/effector/guard.ts","../../src/effector/fork/hydrate.ts","../../src/effector/restore.ts","../../src/effector/fork/scopeBind.ts"],"sourcesContent":["export function forIn<T, Key extends string = string>(\n  obj: Record<Key, T>,\n  cb: (value: T, key: Key) => void,\n) {\n  for (const key in obj) {\n    cb(obj[key], key)\n  }\n}\n\nexport const includes = <T>(list: T[], item: T) => list.includes(item)\n\nexport const removeItem = <T>(list: T[], item: T) => {\n  const pos = list.indexOf(item)\n  if (pos !== -1) {\n    list.splice(pos, 1)\n  }\n}\n\nexport const add = <T>(list: T[], item: T) => list.push(item)\n\nexport function forEach<T>(\n  list: T[],\n  fn: (item: T, index: number, list: T[]) => void,\n): void\nexport function forEach<K, T>(\n  list: Map<K, T>,\n  fn: (item: T, key: K) => void,\n): void\nexport function forEach<T>(list: Set<T>, fn: (item: T) => void): void\nexport function forEach(list: any, fn: Function) {\n  list.forEach(fn)\n}\n","export function assert(condition: unknown, message: string): asserts condition {\n  if (!condition) throw Error(message)\n}\n\nexport const deprecate = (\n  condition: unknown,\n  subject: string,\n  suggestion?: string,\n) =>\n  !condition &&\n  console.error(\n    `${subject} is deprecated${\n      suggestion ? `, use ${suggestion} instead` : ''\n    }`,\n  )\n","import type {Template} from '../forest/index.h'\nimport type {NodeUnit, Node, ID} from './index.h'\nimport {getParent, getGraph} from './getter'\nimport {createNode} from './createNode'\n\ntype DeclarationSourceReporter = (\n  node: Node | 'region',\n  regionStack: RegionStack | null,\n) => void\n\nlet reporter: DeclarationSourceReporter\n\nexport const setGraphInspector = (fn: DeclarationSourceReporter) => {\n  reporter = fn\n}\n\ntype RegionStack = {\n  id: ID\n  parent: RegionStack | null\n  value: any\n  template: Template | null\n  sidRoot?: string\n  meta:\n    | Record<string, unknown>\n    | {\n        type: 'factory'\n        sid?: string\n        name?: string\n        loc: unknown\n        method?: string\n      }\n}\n\nexport let regionStack: RegionStack | null = null\n\nexport const reportDeclaration = (node: Node | 'region') => {\n  if (reporter) {\n    reporter(node, regionStack)\n  }\n}\n\nexport const readTemplate = (): Template | null =>\n  regionStack && regionStack.template\nexport const readSidRoot = (sid?: string | null) => {\n  if (sid && regionStack && regionStack.sidRoot)\n    sid = `${regionStack.sidRoot}|${sid}`\n  return sid\n}\n\nexport function withRegion<T = void>(unit: NodeUnit, cb: () => T): T {\n  const meta = getGraph(unit).meta || {}\n\n  regionStack = {\n    id: getGraph(unit).id,\n    parent: regionStack,\n    value: unit,\n    template: meta.template || readTemplate(),\n    sidRoot: meta.sidRoot || (regionStack && regionStack.sidRoot),\n    meta: meta,\n  }\n  try {\n    return cb()\n  } finally {\n    reportDeclaration('region')\n    regionStack = getParent(regionStack)\n  }\n}\n\nexport const withFactory = ({\n  sid,\n  name,\n  loc,\n  method,\n  fn,\n}: {\n  sid: string\n  name?: string\n  loc?: any\n  method?: string\n  fn: () => any\n}) => {\n  const factoryRootNode = createNode({\n    meta: {sidRoot: readSidRoot(sid), sid, name, loc, method, type: 'factory'},\n  })\n\n  return withRegion(factoryRootNode, fn)\n}\n","import type {Node, NodeUnit, Cmd} from './index.h'\nimport {getGraph, getOwners, getLinks, getValue} from './getter'\nimport {nextNodeID} from './id'\nimport {CROSSLINK} from './tag'\nimport {regionStack} from './region'\nimport {own} from './own'\nimport {add, forEach} from './collection'\n\nexport const arrifyNodes = (\n  list: NodeUnit | Array<NodeUnit | NodeUnit[]> = [],\n): Node[] => (Array.isArray(list) ? list : [list]).flat().map(getGraph)\n\nexport function createNode({\n  node = [],\n  from,\n  source,\n  parent = from || source,\n  to,\n  target,\n  child = to || target,\n  scope = {},\n  meta = {},\n  family: familyRaw = {type: 'regular'},\n  regional,\n}: {\n  node?: Array<Cmd | false | void | null>\n  from?: NodeUnit | NodeUnit[]\n  source?: NodeUnit | NodeUnit[]\n  parent?: NodeUnit | NodeUnit[]\n  to?: NodeUnit | NodeUnit[]\n  target?: NodeUnit | NodeUnit[]\n  child?: NodeUnit | NodeUnit[]\n  scope?: {[name: string]: any}\n  meta?: {[name: string]: any}\n  family?: {\n    type?: 'regular' | 'crosslink' | 'domain'\n    links?: NodeUnit | NodeUnit[]\n    owners?: NodeUnit | Array<NodeUnit | NodeUnit[]>\n  }\n  regional?: boolean\n} = {}): Node {\n  const sources = arrifyNodes(parent)\n  const links = arrifyNodes(familyRaw.links)\n  const owners = arrifyNodes(familyRaw.owners)\n  const seq: Cmd[] = []\n  forEach(node, item => item && add(seq, item))\n  const result: Node = {\n    id: nextNodeID(),\n    seq,\n    next: arrifyNodes(child),\n    meta,\n    scope,\n    family: {\n      type: familyRaw.type || CROSSLINK,\n      links,\n      owners,\n    },\n  }\n  forEach(links, link => add(getOwners(link), result))\n  forEach(owners, owner => add(getLinks(owner), result))\n  forEach(sources, source => add(source.next, result))\n  if (regional && regionStack) {\n    own(getValue(regionStack), [result])\n  }\n  return result\n}\n","import type {Leaf} from '../forest/index.h'\n\nimport type {Node, NodeUnit, StateRef, Stack} from './index.h'\nimport {readRef} from './stateRef'\nimport {getForkPage, getGraph, getMeta, getParent, getValue} from './getter'\nimport {STORE, EFFECT, SAMPLER, STACK, BARRIER, VALUE, REG_A, MAP} from './tag'\nimport type {Scope} from './unit.h'\nimport {add, forEach} from './collection'\n\n/** Names of priority groups */\ntype PriorityTag = 'child' | 'pure' | 'read' | 'barrier' | 'sampler' | 'effect'\n\nexport type BarrierPriorityTag = 'read' | 'barrier' | 'sampler' | 'effect'\n\n/**\n * Position in the current branch,\n * including call stack, priority type\n * and index of next step in the executed Node\n */\ntype Layer = {\n  idx: number\n  stack: Stack\n  type: PriorityTag\n  id: number\n}\n\n/** Queue as linked list or skew heap */\ntype QueueItem = {\n  /** node value */\n  v: Layer\n  /** left node. always null in queue but used in skew heap */\n  l: QueueItem | null\n  /** right node */\n  r: QueueItem | null\n}\ntype QueueBucket = {\n  first: QueueItem | null\n  last: QueueItem | null\n  size: number\n}\n\n/** Dedicated local metadata */\ntype Local = {\n  fail: boolean\n  failReason?: unknown\n  scope: {[key: string]: any}\n}\n\nlet heap: QueueItem | null = null\n\nconst merge = (a: QueueItem | null, b: QueueItem | null): QueueItem | null => {\n  if (!a) return b\n  if (!b) return a\n\n  let ret\n  if (\n    /**\n     * if both nodes has the same PriorityType\n     * and first node is created after second one\n     */\n    (a.v.type === b.v.type && a.v.id > b.v.id) ||\n    /**\n     * greater priority mean bucket of first node is executed later\n     * e.g  a: \"sampler\", b: \"barrier\"\n     */\n    getPriority(a.v.type) > getPriority(b.v.type)\n  ) {\n    ret = a\n    a = b\n    b = ret\n  }\n  ret = merge(a.r, b)\n  a.r = a.l\n  a.l = ret\n\n  return a\n}\n\n/** queue buckets for each PriorityType */\nconst queue: QueueBucket[] = []\nlet ix = 0\nwhile (ix < 6) {\n  /**\n   * although \"sampler\" and \"barrier\" are using heap instead of linked list,\n   * their buckets are still useful: they maintains size of heap queue\n   */\n  add(queue, {first: null, last: null, size: 0})\n  ix += 1\n}\n\nconst deleteMin = () => {\n  for (let i = 0; i < 6; i++) {\n    const list = queue[i]\n    if (list.size > 0) {\n      /**\n       * bucket 3 is for \"barrier\" PriorityType (used in combine)\n       * bucket 4 is for \"sampler\" PriorityType (used in sample and guard)\n       */\n      if (i === 3 || i === 4) {\n        list.size -= 1\n        const value = heap!.v\n        heap = merge(heap!.l, heap!.r)\n        return value\n      }\n      if (list.size === 1) {\n        list.last = null\n      }\n      const item = list.first\n      list.first = item!.r\n      list.size -= 1\n      return item!.v\n    }\n  }\n}\nconst pushFirstHeapItem = (\n  type: PriorityTag,\n  page: Leaf | null,\n  node: Node,\n  parent: Stack | null,\n  value: any,\n  scope?: Scope | null | void,\n  meta?: Record<string, any> | void,\n) =>\n  pushHeap(\n    0,\n    {\n      a: null,\n      b: null,\n      node,\n      parent,\n      value,\n      page,\n      scope,\n      meta,\n    },\n    type,\n  )\nconst pushHeap = (\n  idx: number,\n  stack: Stack,\n  type: PriorityTag,\n  id: number = 0,\n) => {\n  const priority = getPriority(type)\n  const bucket: QueueBucket = queue[priority]\n  const item: QueueItem = {\n    v: {\n      idx,\n      stack,\n      type,\n      id,\n    },\n    l: null,\n    r: null,\n  }\n  /**\n   * bucket 3 is for \"barrier\" PriorityType (used in combine)\n   * bucket 4 is for \"sampler\" PriorityType (used in sample and guard)\n   */\n  if (priority === 3 || priority === 4) {\n    heap = merge(heap, item)\n  } else {\n    if (bucket.size === 0) {\n      bucket.first = item\n    } else {\n      bucket.last!.r = item\n    }\n    bucket.last = item\n  }\n  bucket.size += 1\n}\n\nconst getPriority = (t: PriorityTag) => {\n  switch (t) {\n    case 'child':\n      return 0\n    case 'pure':\n      return 1\n    case 'read':\n      return 2\n    case BARRIER:\n      return 3\n    case SAMPLER:\n      return 4\n    case EFFECT:\n      return 5\n    default:\n      return -1\n  }\n}\n\nconst barriers = new Set<string | number>()\n\nlet isRoot = true\nexport let isWatch = false\nexport let isPure = false\nexport let currentPage: Leaf | null = null\nexport let forkPage: Scope | void | null\nexport const setForkPage = (newForkPage: Scope | void | null) => {\n  forkPage = newForkPage\n}\nexport const setCurrentPage = (newPage: Leaf | null) => {\n  currentPage = newPage\n}\n\nconst getPageForRef = (page: Leaf | null, id: string) => {\n  if (page) {\n    while (page && !page.reg[id]) {\n      page = getParent(page)\n    }\n    if (page) return page\n  }\n  return null\n}\nexport const getPageRef = (\n  page: Leaf | null,\n  forkPage: Scope | null | void,\n  node: Node | null,\n  ref: StateRef,\n  isGetState?: boolean,\n) => {\n  const pageForRef = getPageForRef(page, ref.id)\n  if (pageForRef) return pageForRef.reg[ref.id]\n  if (forkPage) {\n    initRefInScope(forkPage!, ref, isGetState)\n    return forkPage.reg[ref.id]\n  }\n  return ref\n}\n\n/** Introspection api internals */\ntype Inspector = (stack: Stack, local: Local) => void\nlet inspector: Inspector\nexport const setInspector = (newInspector: Inspector) => {\n  inspector = newInspector\n}\n\nexport function launch(config: {\n  target: NodeUnit | NodeUnit[]\n  params?: any\n  defer?: boolean\n  page?: Leaf | void | null\n  scope?: Scope | void | null\n  stack?: Stack | void\n  meta?: Record<string, any> | void\n}): void\nexport function launch(unit: NodeUnit, payload?: any, upsert?: boolean): void\nexport function launch(unit: any, payload?: any, upsert?: boolean) {\n  let pageForLaunch = currentPage\n  let stackForLaunch = null\n  let forkPageForLaunch = forkPage\n  let meta: Record<string, any> | void\n  if (unit.target) {\n    payload = unit.params\n    upsert = unit.defer\n    meta = unit.meta\n    pageForLaunch = 'page' in unit ? unit.page : pageForLaunch\n    if (unit[STACK]) stackForLaunch = unit[STACK]\n    forkPageForLaunch = getForkPage(unit) || forkPageForLaunch\n    unit = unit.target\n  }\n  if (forkPageForLaunch && forkPage && forkPageForLaunch !== forkPage) {\n    forkPage = null\n  }\n  if (Array.isArray(unit)) {\n    for (let i = 0; i < unit.length; i++) {\n      pushFirstHeapItem(\n        'pure',\n        pageForLaunch,\n        getGraph(unit[i]),\n        stackForLaunch,\n        payload[i],\n        forkPageForLaunch,\n        meta,\n      )\n    }\n  } else {\n    pushFirstHeapItem(\n      'pure',\n      pageForLaunch,\n      getGraph(unit),\n      stackForLaunch,\n      payload,\n      forkPageForLaunch,\n      meta,\n    )\n  }\n  if (upsert && !isRoot) return\n  /** main execution code */\n  const lastStartedState = {\n    isRoot,\n    currentPage,\n    scope: forkPage,\n    isWatch,\n    isPure,\n  }\n  isRoot = false\n  let stop: boolean\n  let skip: boolean\n  let node: Node\n  let value: Layer | undefined\n  let page: Leaf | null\n  let reg: Record<string, StateRef> | void\n  kernelLoop: while ((value = deleteMin())) {\n    const {idx, stack, type} = value\n    node = stack.node\n    currentPage = page = stack.page\n    forkPage = getForkPage(stack)\n    if (page) reg = page.reg\n    else if (forkPage) reg = forkPage.reg\n    // reg = (page ? page : forkPage ? forkPage : node).reg\n    const hasPageReg = !!page\n    const hasScopeReg = !!forkPage\n    const local: Local = {\n      fail: false,\n      scope: node.scope,\n    }\n    stop = skip = false\n    for (let stepn = idx; stepn < node.seq.length && !stop; stepn++) {\n      const step = node.seq[stepn]\n      if (step.order) {\n        const {priority, barrierID} = step.order\n        const id = barrierID\n          ? page\n            ? `${page.fullID}_${barrierID}`\n            : barrierID\n          : 0\n        if (stepn !== idx || type !== priority) {\n          if (barrierID) {\n            if (!barriers.has(id)) {\n              barriers.add(id)\n              pushHeap(stepn, stack, priority, barrierID)\n            }\n          } else {\n            pushHeap(stepn, stack, priority)\n          }\n          continue kernelLoop\n        }\n        barrierID && barriers.delete(id)\n      }\n      switch (step.type) {\n        case 'mov': {\n          const data = step.data\n          let value\n          //prettier-ignore\n          switch (data.from) {\n            case STACK: value = getValue(stack); break\n            case REG_A: /** fall-through case */\n            case 'b':\n              value = stack[data.from]\n              break\n            case VALUE: value = data.store; break\n            case STORE:\n              if (reg && !reg[data.store.id]) {\n                // if (!page.parent) {\n                if (hasPageReg) {\n                  const pageForRef = getPageForRef(page, data.store.id)\n                  stack.page = page = pageForRef\n                  if (pageForRef) {\n                    reg = pageForRef.reg\n                  } else if (hasScopeReg) {\n                    initRefInScope(forkPage!, data.store, false, true, data.softRead)\n                    reg = forkPage!.reg\n                  } else {\n                    reg = undefined //node.reg\n                  }\n                } else if (hasScopeReg) {\n                  /** StateRef in Scope.reg created only when needed */\n                  initRefInScope(forkPage!, data.store, false, true, data.softRead)\n                } else {\n                  // console.error('should not happen')\n                  /** StateRef should exists at least in Node itself, but it is not found */\n                }\n                // }\n              }\n              // value = getPageRef(page, forkPage, node, data.store.id).current\n              value = readRef(reg ? reg[data.store.id] || data.store : data.store)\n              break\n          }\n          //prettier-ignore\n          switch (data.to) {\n            case STACK: stack.value = value; break\n            case REG_A: /** fall-through case */\n            case 'b':\n              stack[data.to] = value\n              break\n            case STORE:\n              getPageRef(page, forkPage, node, data.target).current = value\n              break\n          }\n          break\n        }\n        case 'compute':\n          const data = step.data\n          if (data.fn) {\n            isWatch = getMeta(node, 'op') === 'watch'\n            isPure = data.pure\n            const computationResult = data.safe\n              ? (0 as any, data.fn)(getValue(stack), local.scope, stack)\n              : tryRun(local, data.fn, stack)\n            if (data.filter) {\n              /**\n               * handled edge case: if step.fn will throw,\n               * tryRun will return null\n               * thereby forcing that branch to stop\n               */\n              skip = !computationResult\n            } else {\n              stack.value = computationResult\n            }\n            isWatch = lastStartedState.isWatch\n            isPure = lastStartedState.isPure\n          }\n          break\n      }\n      stop = local.fail || skip\n    }\n    if (inspector) {\n      inspector(stack, local)\n    }\n    if (!stop) {\n      const finalValue = getValue(stack)\n      const forkPage = getForkPage(stack)\n      forEach(node.next, nextNode => {\n        pushFirstHeapItem('child', page, nextNode, stack, finalValue, forkPage)\n      })\n      if (forkPage) {\n        if (getMeta(node, 'needFxCounter'))\n          pushFirstHeapItem(\n            'child',\n            page,\n            forkPage.fxCount,\n            stack,\n            finalValue,\n            forkPage,\n          )\n        if (getMeta(node, 'storeChange'))\n          pushFirstHeapItem(\n            'child',\n            page,\n            forkPage.storeChange,\n            stack,\n            finalValue,\n            forkPage,\n          )\n        if (getMeta(node, 'warnSerialize'))\n          pushFirstHeapItem(\n            'child',\n            page,\n            forkPage.warnSerializeNode,\n            stack,\n            finalValue,\n            forkPage,\n          )\n        const additionalLinks = forkPage.additionalLinks[node.id]\n        if (additionalLinks) {\n          forEach(additionalLinks, nextNode => {\n            pushFirstHeapItem(\n              'child',\n              page,\n              nextNode,\n              stack,\n              finalValue,\n              forkPage,\n            )\n          })\n        }\n      }\n    }\n  }\n  isRoot = lastStartedState.isRoot\n  currentPage = lastStartedState.currentPage\n  forkPage = getForkPage(lastStartedState)\n}\n\nconst noopParser = (x: any) => x\n\nexport const initRefInScope = (\n  scope: Scope,\n  sourceRef: StateRef,\n  isGetState?: boolean,\n  isKernelCall?: boolean,\n  softRead?: boolean,\n) => {\n  const refsMap = scope.reg\n  if (refsMap[sourceRef.id]) return\n  const sid = sourceRef.sid\n  const serialize = sourceRef?.meta?.serialize\n  const parser =\n    scope.fromSerialize && serialize !== 'ignore'\n      ? serialize?.read || noopParser\n      : noopParser\n  const ref: StateRef = {\n    id: sourceRef.id,\n    current: sourceRef.current,\n    meta: sourceRef.meta,\n  }\n\n  if (ref.id in scope.values.idMap) {\n    ref.current = scope.values.idMap[ref.id]\n  } else if (sid && sid in scope.values.sidMap && !(sid in scope.sidIdMap)) {\n    ref.current = parser(scope.values.sidMap[sid])\n  } else {\n    if (sourceRef.before && !softRead) {\n      let isFresh = false\n      const needToAssign = isGetState || !sourceRef.noInit || isKernelCall\n      forEach(sourceRef.before, cmd => {\n        switch (cmd.type) {\n          case MAP: {\n            const from = cmd.from\n            if (from || cmd.fn) {\n              if (from) initRefInScope(scope, from, isGetState, isKernelCall)\n              const value = from && refsMap[from.id].current\n              if (needToAssign) {\n                ref.current = cmd.fn ? cmd.fn(value) : value\n              }\n            }\n            break\n          }\n          case 'field': {\n            if (!isFresh) {\n              isFresh = true\n              if (Array.isArray(ref.current)) {\n                ref.current = [...ref.current]\n              } else {\n                ref.current = {...ref.current}\n              }\n            }\n            initRefInScope(scope, cmd.from, isGetState, isKernelCall)\n            if (needToAssign) {\n              const from = refsMap[cmd.from.id]\n              ref.current[cmd.field] = refsMap[from.id].current\n            }\n            break\n          }\n          // case 'closure':\n          //   break\n        }\n      })\n    }\n  }\n  if (sid) scope.sidIdMap[sid] = sourceRef.id\n  refsMap[sourceRef.id] = ref\n}\n\n/** try catch for external functions */\nconst tryRun = (local: Local, fn: Function, stack: Stack) => {\n  try {\n    return fn(getValue(stack), local.scope, stack)\n  } catch (err) {\n    console.error(err)\n    local.fail = true\n    local.failReason = err\n  }\n}\n","import type {Store, CommonUnit, Domain} from './unit.h'\nimport {is} from './is'\nimport {getParent, getCompositeName} from './getter'\nimport {forIn} from './collection'\n\nexport function unitObjectName(objOrArr: any, method: string = 'combine') {\n  let name = method + '('\n  let comma = ''\n  let i = 0\n  forIn(objOrArr, unit => {\n    /* inlined max object names constant */\n    if (i < 25) {\n      if (unit != null) {\n        name += comma\n        name += is.unit(unit)\n          ? getCompositeName(unit as CommonUnit | Domain).fullName\n          : (unit as any).toString()\n      }\n      i += 1\n      comma = ', '\n    }\n  })\n  return name + ')'\n}\n\nexport function setStoreName<State>(store: Store<State>, rawName: string) {\n  store.shortName = rawName\n  Object.assign(getCompositeName(store), createName(rawName, getParent(store)))\n}\n\nexport type CompositeName = {\n  shortName: string\n  fullName: string\n  path: string[]\n}\n\nexport function createName(name: string, parent?: Domain): CompositeName {\n  let path: string[]\n  let fullName\n  const shortName = name\n  if (!parent) {\n    path = name.length === 0 ? [] : [name]\n    fullName = name\n  } else {\n    const composite = getCompositeName(parent)\n    if (name.length === 0) {\n      path = composite.path\n      fullName = composite.fullName\n    } else {\n      path = composite.path.concat([name])\n      fullName =\n        composite.fullName.length === 0\n          ? name\n          : '' + composite.fullName + '/' + name\n    }\n  }\n  return {shortName, fullName, path}\n}\n","import {forIn} from './collection'\nimport {assertObject, isObject, isVoid} from './is'\n\nexport function processArgsToConfig(\n  arg: any,\n  singleArgument: true,\n): [any, any | void]\nexport function processArgsToConfig(args: any[]): [any[], any | void]\nexport function processArgsToConfig(\n  args: any[],\n  singleArgument?: boolean,\n): [any[], any | void] {\n  const rawConfig = singleArgument ? args : args[0]\n  assertObject(rawConfig)\n  let metadata = rawConfig.or\n  const childConfig = rawConfig.and\n  if (childConfig) {\n    const unwrappedNestedValue = singleArgument ? childConfig : childConfig[0]\n    /**\n     * if there is no \"and\" field then we reached the leaf of the tree\n     * and this is an original user-defined argument\n     *\n     * note that in this case we're returning all arguments, not the only one been unwrapped\n     **/\n    if (!isObject(unwrappedNestedValue) || !('and' in unwrappedNestedValue)) {\n      args = childConfig\n    } else {\n      //@ts-expect-error\n      const nested = processArgsToConfig(childConfig, singleArgument)\n\n      args = nested[0]\n      metadata = {...metadata, ...nested[1]}\n    }\n  }\n  return [args, metadata]\n}\n\n/**\nprocessed fields:\n\n'name',\n'sid',\n'loc',\n'handler',\n'updateFilter',\n'parent',\n'serialize',\n'named',\n'derived',\n*/\nexport const flattenConfig = (part: any, config: Record<string, any> = {}) => {\n  if (isObject(part)) {\n    flattenConfig(part.or, config)\n    forIn(part, (value, field) => {\n      if (!isVoid(value) && field !== 'or' && field !== 'and') {\n        config[field] = value\n      }\n    })\n    flattenConfig(part.and, config)\n  }\n  return config\n}\n","import {readTemplate} from './region'\nimport type {Template, TemplateHandlers} from '../forest/index.h'\n\nexport function applyTemplate<K extends keyof TemplateHandlers>(\n  method: K,\n  ...args: Parameters<TemplateHandlers[K]> extends [Template, ...infer Args]\n    ? Args\n    : never\n): ReturnType<TemplateHandlers[K]> | void {\n  const template = readTemplate()\n  if (template) {\n    const fn = template.handlers[method]\n    // @ts-expect-error\n    if (fn) return fn(template, ...args)\n  }\n}\n","import type {Template} from '../forest/index.h'\nimport type {Store, Event, CommonUnit, Effect, Domain} from './unit.h'\nimport type {Subscriber, Config, Cmd, Kind} from './index.h'\n\nimport {observableSymbol} from './observable'\n\nimport {\n  is,\n  isObject,\n  isFunction,\n  assertObject,\n  assertNodeSet,\n  isVoid,\n} from './is'\nimport {calc, mov, read, userFnCall} from './step'\nimport {createStateRef, readRef, addRefOp} from './stateRef'\nimport {nextUnitID} from './id'\nimport {callStackAReg, callARegStack, callStack} from './caller'\nimport {own} from './own'\nimport {createNode} from './createNode'\nimport {\n  launch,\n  currentPage,\n  forkPage,\n  setCurrentPage,\n  initRefInScope,\n  isPure,\n} from './kernel'\n\nimport {createName} from './naming'\nimport {createLinkNode} from './forward'\nimport {watchUnit} from './watch'\nimport {createSubscription} from './subscription'\nimport {readTemplate, readSidRoot, reportDeclaration} from './region'\nimport {\n  getSubscribers,\n  getStoreState,\n  getGraph,\n  getParent,\n  setMeta,\n  getMeta,\n} from './getter'\nimport {assert, deprecate} from './throw'\nimport {DOMAIN, STORE, EVENT, MAP, FILTER, STACK, REG_A} from './tag'\nimport {applyTemplate} from './template'\nimport {forEach} from './collection'\nimport {flattenConfig} from './config'\n\nexport const applyParentHook = (\n  source: CommonUnit,\n  target: CommonUnit,\n  hookType: 'event' | 'effect' = EVENT,\n) => {\n  if (getParent(source)) getParent(source).hooks[hookType](target)\n}\n\nexport const initUnit = (kind: Kind, unit: any, rawConfig: any) => {\n  const config = flattenConfig(rawConfig)\n  const isDomain = kind === DOMAIN\n  const id = nextUnitID()\n  const {sid = null, named = null, domain = null, parent = domain} = config\n  const name = named ? named : config.name || (isDomain ? '' : id)\n  const compositeName = createName(name, parent)\n  const meta: Record<string, any> = {\n    op: (unit.kind = kind),\n    name: (unit.shortName = name),\n    sid: (unit.sid = readSidRoot(sid)),\n    named,\n    unitId: (unit.id = id),\n    serialize: config.serialize,\n    derived: config.derived,\n    config,\n  }\n  unit.parent = parent\n  unit.compositeName = compositeName\n  unit.defaultConfig = config\n  unit.thru = (fn: Function) => {\n    deprecate(false, 'thru', 'js pipe')\n    return fn(unit)\n  }\n  unit.getType = () => compositeName.fullName\n  if (!isDomain) {\n    unit.subscribe = (observer: Subscriber<any>) => {\n      assertObject(observer)\n      return unit.watch(\n        isFunction(observer)\n          ? observer\n          : (upd: any) => observer.next && observer.next(upd),\n      )\n    }\n    unit[observableSymbol] = () => unit\n    const template = readTemplate()\n    if (template) meta.nativeTemplate = template\n  }\n  return meta\n}\nexport const createNamedEvent = (named: string) => createEvent({named})\n\nconst deriveEvent = (\n  event: Event<any>,\n  op: 'map' | 'filterMap' | 'filter',\n  fn: Function,\n  node: Cmd[],\n) => {\n  let config\n  if (isObject(fn)) {\n    config = fn\n    fn = (fn as unknown as {fn: Function}).fn\n  }\n  const mapped = createEvent({\n    name: `${event.shortName} → *`,\n    derived: true,\n    and: config,\n  })\n  createLinkNode(event, mapped, node, op, fn)\n  return mapped\n}\n\nfunction callCreate<T>(\n  unit: Event<T> | Effect<T, any, any>,\n  template: Template | null,\n  payload: T,\n  args: any[],\n) {\n  const oldPage = currentPage\n  let page = null\n  if (template) {\n    page = currentPage\n    while (page && page.template !== template) {\n      page = getParent(page)\n    }\n  }\n  setCurrentPage(page)\n  const result = unit.create(payload, args)\n  setCurrentPage(oldPage)\n  return result\n}\n\nexport function createEvent<Payload = any>(\n  nameOrConfig?: any,\n  maybeConfig?: any,\n): Event<Payload> {\n  const config = flattenConfig({\n    or: maybeConfig,\n    and: typeof nameOrConfig === 'string' ? {name: nameOrConfig} : nameOrConfig,\n  }) as any\n  const event = ((payload: Payload, ...args: unknown[]) => {\n    deprecate(\n      !getMeta(event, 'derived'),\n      'call of derived event',\n      'createEvent',\n    )\n    deprecate(!isPure, 'unit call from pure function', 'operators like sample')\n    if (currentPage) {\n      return callCreate(event, template, payload, args)\n    }\n    return event.create(payload, args)\n  }) as Event<Payload>\n  const template = readTemplate()\n  const finalEvent = Object.assign(event, {\n    graphite: createNode({\n      meta: initUnit(config.actualOp || EVENT, event, config),\n      regional: true,\n    }),\n    create(params: Payload, _: any[]) {\n      launch({target: event, params, scope: forkPage!})\n      return params\n    },\n    watch: (fn: (payload: Payload) => any) => watchUnit(event, fn),\n    map: (fn: Function) => deriveEvent(event, MAP, fn, [userFnCall()]),\n    filter: (fn: {fn: Function}) =>\n      //@ts-expect-error\n      deriveEvent(event, FILTER, fn.fn ? fn : fn.fn, [\n        userFnCall(callStack, true),\n      ]),\n    filterMap: (fn: Function) =>\n      deriveEvent(event, 'filterMap', fn, [\n        userFnCall(),\n        calc(value => !isVoid(value), true),\n      ]),\n    prepend(fn: Function) {\n      const contramapped: Event<any> = createEvent('* → ' + event.shortName, {\n        parent: getParent(event),\n      })\n      applyTemplate('eventPrepend', getGraph(contramapped))\n      createLinkNode(contramapped, event, [userFnCall()], 'prepend', fn)\n      applyParentHook(event, contramapped)\n      return contramapped\n    },\n  })\n  if (config?.domain) {\n    config.domain.hooks.event(finalEvent)\n  }\n  setMeta(finalEvent, 'id', finalEvent.graphite.id)\n  reportDeclaration(finalEvent.graphite)\n  return finalEvent\n}\nfunction on<State>(\n  store: Store<State>,\n  methodName: string,\n  nodeSet: CommonUnit | CommonUnit[],\n  fn: Function,\n) {\n  assertNodeSet(nodeSet, methodName, 'first argument')\n  assert(isFunction(fn), 'second argument should be a function')\n  deprecate(\n    !getMeta(store, 'derived'),\n    `${methodName} in derived store`,\n    `${methodName} in store created via createStore`,\n  )\n  forEach(Array.isArray(nodeSet) ? nodeSet : [nodeSet], trigger => {\n    store.off(trigger)\n    getSubscribers(store).set(\n      trigger,\n      createSubscription(updateStore(trigger, store, 'on', callARegStack, fn)),\n    )\n  })\n  return store\n}\nexport function createStore<State>(\n  defaultState: State,\n  props?: Config,\n): Store<State> {\n  const config = flattenConfig(props)\n  const plainState = createStateRef(defaultState)\n  const updates = createEvent({named: 'updates', derived: true})\n  applyTemplate('storeBase', plainState)\n  const plainStateId = plainState.id\n  const store = {\n    subscribers: new Map(),\n    updates,\n    defaultState,\n    stateRef: plainState,\n    getState() {\n      let targetRef = plainState\n      let reachedPage\n      if (currentPage) {\n        let page = currentPage\n        while (page && !page.reg[plainStateId]) {\n          page = getParent(page)\n        }\n        if (page) reachedPage = page\n      }\n      if (!reachedPage && forkPage) {\n        initRefInScope(forkPage, plainState, true)\n        reachedPage = forkPage\n      }\n      if (reachedPage) targetRef = reachedPage.reg[plainStateId]\n      return readRef(targetRef)\n    },\n    setState: (state: State) =>\n      launch({\n        target: store,\n        params: state,\n        defer: true,\n        scope: forkPage!,\n      }),\n    reset(...units: CommonUnit[]) {\n      forEach(units, unit =>\n        on(store, '.reset', unit, () => store.defaultState),\n      )\n      return store\n    },\n    on(nodeSet: CommonUnit | CommonUnit[], fn: Function) {\n      return on(store, '.on', nodeSet, fn)\n    },\n    off(unit: CommonUnit) {\n      const currentSubscription = getSubscribers(store).get(unit)\n      if (currentSubscription) {\n        currentSubscription()\n        getSubscribers(store).delete(unit)\n      }\n      return store\n    },\n    map(fn: (value: any, prevArg?: any) => any, firstState?: any) {\n      let config\n      if (isObject(fn)) {\n        config = fn\n        fn = (fn as unknown as {fn: (value: any) => any}).fn\n      }\n      deprecate(\n        isVoid(firstState),\n        'second argument of store.map',\n        'updateFilter',\n      )\n      let lastResult\n      const storeState = store.getState()\n      const template = readTemplate()\n      if (template) {\n        lastResult = null\n      } else if (!isVoid(storeState)) {\n        lastResult = fn(storeState, firstState)\n      }\n\n      const innerStore: Store<any> = createStore(lastResult, {\n        name: `${store.shortName} → *`,\n        derived: true,\n        // @ts-expect-error some mismatch in config types\n        and: config,\n      })\n      const linkNode = updateStore(store, innerStore, MAP, callStackAReg, fn)\n      addRefOp(getStoreState(innerStore), {\n        type: MAP,\n        fn,\n        from: plainState,\n      })\n      getStoreState(innerStore).noInit = true\n      applyTemplate('storeMap', plainState, linkNode)\n      return innerStore\n    },\n    watch(eventOrFn: any, fn?: Function) {\n      if (!fn || !is.unit(eventOrFn)) {\n        const subscription = watchUnit(store, eventOrFn)\n        if (!applyTemplate('storeWatch', plainState, eventOrFn)) {\n          eventOrFn(store.getState())\n        }\n        return subscription\n      }\n      assert(isFunction(fn), 'second argument should be a function')\n      return (eventOrFn as CommonUnit).watch((payload: any) =>\n        fn(store.getState(), payload),\n      )\n    },\n  } as unknown as Store<State>\n  const meta = initUnit(STORE, store, config)\n  const updateFilter = store.defaultConfig.updateFilter\n  store.graphite = createNode({\n    scope: {state: plainState, fn: updateFilter},\n    node: [\n      calc((upd, _, stack) => {\n        if (stack.scope && !stack.scope.reg[plainState.id]) {\n          stack.b = true\n        }\n        return upd\n      }),\n      read(plainState),\n      calc((upd, _, {a, b}) => !isVoid(upd) && (upd !== a || b), true),\n      updateFilter && userFnCall(callStackAReg, true),\n      mov({from: STACK, target: plainState}),\n    ],\n    child: updates,\n    meta: {\n      ...meta,\n      defaultState,\n    },\n    regional: true,\n  })\n  setMeta(store, 'id', store.graphite.id)\n  setMeta(store, 'rootStateRefId', plainStateId)\n  const serializeMeta = getMeta(store, 'serialize')\n  const derived = getMeta(store, 'derived')\n  const ignored = serializeMeta === 'ignore'\n  const sid: string | null = getMeta(store, 'sid')\n  if (sid) {\n    setMeta(store, 'storeChange', true)\n    plainState.sid = sid\n  }\n  if (!sid && !ignored && !derived) {\n    setMeta(store, 'warnSerialize', true)\n  }\n  assert(\n    derived || !isVoid(defaultState),\n    \"current state can't be undefined, use null instead\",\n  )\n  own(store, [updates])\n  if (config?.domain) {\n    config.domain.hooks.store(store)\n  }\n\n  if (!derived) {\n    store.reinit = createEvent<void>({\n      named: 'reinit',\n    })\n    store.reset(store.reinit)\n  }\n\n  plainState.meta = store.graphite.meta\n\n  reportDeclaration(store.graphite)\n\n  return store\n}\n\nconst updateStore = (\n  from: CommonUnit,\n  store: Store<any>,\n  op: string,\n  caller: typeof callStackAReg,\n  fn: Function,\n) => {\n  const storeRef = getStoreState(store)\n  const reader = mov({\n    store: storeRef,\n    to: REG_A,\n    priority: 'read',\n  })\n  if (op === MAP) reader.data.softRead = true\n  const node = [reader, userFnCall(caller)]\n  applyTemplate(\n    'storeOnMap',\n    storeRef,\n    node,\n    is.store(from) && getStoreState(from),\n  )\n  return createLinkNode(from, store, node, op, fn)\n}\n","export const STORE = 'store'\nexport const EVENT = 'event'\nexport const EFFECT = 'effect'\nexport const DOMAIN = 'domain'\nexport const SCOPE = 'scope'\nexport const SAMPLER = 'sampler'\nexport const CROSSLINK = 'crosslink'\nexport const MAP = 'map'\nexport const STACK = 'stack'\nexport const BARRIER = 'barrier'\nexport const VALUE = 'value'\nexport const SAMPLE = 'sample'\nexport const FILTER = 'filter'\nexport const REG_A = 'a'\n","import type {Store} from './unit.h'\nimport {createStore} from './createUnit'\nimport {createStateRef, addRefOp} from './stateRef'\nimport {mov, calc, read, userFnCall} from './step'\nimport {processArgsToConfig} from './config'\nimport {getStoreState, setMeta} from './getter'\nimport {is, isFunction, isObject, isVoid} from './is'\nimport {unitObjectName} from './naming'\nimport {createLinkNode} from './forward'\nimport {assert, deprecate} from './throw'\nimport {readTemplate} from './region'\nimport {forIn} from './collection'\nimport {BARRIER, MAP, REG_A, VALUE} from './tag'\nimport {applyTemplate} from './template'\nimport type {Config} from './index.h'\n\nexport function combine(...args: any[]): Store<any> {\n  let handler\n  let stores\n  let config\n  ;[args, config] = processArgsToConfig(args)\n  const rawHandler = args[args.length - 1]\n  if (isFunction(rawHandler)) {\n    stores = args.slice(0, -1)\n    handler = rawHandler\n  } else {\n    stores = args\n  }\n\n  let structStoreShape\n  let shapeReady\n  if (stores.length === 1) {\n    const obj = stores[0]\n    /*\n      without edge case combine(Color, (Color) => '~')\n      */\n    if (!is.store(obj)) {\n      /*\n      case combine([R,G,B], ([R,G,B]) => '~')\n      case combine({R,G,B}, ({R,G,B}) => '~')\n\n      edge case combine([Color], ([Color]) => '~')\n      edge case combine({Color}, ({Color}) => '~')\n\n      edge case combine([R,G,B])\n      edge case combine({R,G,B})\n\n      edge case combine([Color])\n      edge case combine({Color})\n      */\n      structStoreShape = obj\n      shapeReady = true\n    }\n  }\n  let noArraySpread: boolean | void\n  if (!shapeReady) {\n    /*\n    case combine(R,G,B, (R,G,B) => '~')\n    */\n    structStoreShape = stores\n    /*\n    without edge case combine(R,G,B)\n    without edge case combine(Color)\n    */\n    if (handler) {\n      noArraySpread = true\n      const fn = handler\n      handler = (list: any[]) => fn(...list)\n    }\n  }\n  assert(isObject(structStoreShape), 'shape should be an object')\n  return storeCombination(\n    Array.isArray(structStoreShape),\n    !noArraySpread,\n    structStoreShape,\n    config,\n    handler,\n  )\n}\n\nconst storeCombination = (\n  isArray: boolean,\n  needSpread: boolean,\n  obj: any,\n  config?: Config,\n  fn?: (upd: any) => any,\n) => {\n  const clone = isArray ? (list: any) => [...list] : (obj: any) => ({...obj})\n  const defaultState: Record<string, any> = isArray ? [] : {}\n\n  const stateNew = clone(defaultState)\n  const rawShape = createStateRef(stateNew)\n  const isFresh = createStateRef(true)\n  rawShape.type = isArray ? 'list' : 'shape'\n  rawShape.noInit = true\n  applyTemplate('combineBase', rawShape, isFresh)\n  const store = createStore(stateNew, {\n    name: unitObjectName(obj),\n    derived: true,\n    and: config,\n  })\n  const storeStateRef = getStoreState(store)\n  storeStateRef.noInit = true\n  setMeta(store, 'isCombine', true)\n  const rawShapeReader = read(rawShape)\n  /**\n   * usual ref reading has very high priority, which leads to data races\n   * ref reading for combine should have same \"barrier\" priority but without batching\n   * (thats why order has no \"barrierID\" field, which assume batching)\n   **/\n  rawShapeReader.order = {priority: 'barrier'}\n  /**\n   * Soft store reading is required for\n   * setting target store as inited in scope\n   * for preventing retriggering issues\n   **/\n  const softReader = mov({\n    store: storeStateRef,\n    to: 'b',\n    priority: 'read',\n  })\n  softReader.data.softRead = true\n  const node = [\n    calc((upd, _, stack) => {\n      if (stack.scope && !stack.scope.reg[rawShape.id]) {\n        stack.c = true\n      }\n      return upd\n    }),\n    rawShapeReader,\n    mov({store: isFresh, to: 'b'}),\n    calc((upd, {key}, reg) => {\n      if (reg.c || upd !== reg.a[key]) {\n        if (needSpread && reg.b) {\n          reg.a = clone(reg.a)\n        }\n        reg.a[key] = upd\n        return true\n      }\n    }, true),\n    mov({from: REG_A, target: rawShape}),\n    mov({from: VALUE, store: false, target: isFresh}),\n    mov({\n      from: VALUE,\n      store: true,\n      target: isFresh,\n      priority: BARRIER,\n      batch: true,\n    }),\n    read(rawShape, true),\n    fn && userFnCall(),\n    softReader,\n  ]\n  forIn(obj, (child: Store<any> | any, key) => {\n    if (!is.store(child)) {\n      assert(\n        !is.unit(child) && !isVoid(child),\n        `combine expects a store in a field ${key}`,\n      )\n      stateNew[key] = defaultState[key] = child\n      return\n    }\n    defaultState[key] = child.defaultState\n    stateNew[key] = child.getState()\n    const linkNode = createLinkNode(child, store, node, 'combine', fn)\n    linkNode.scope.key = key\n    const childRef = getStoreState(child)\n    addRefOp(rawShape, {type: 'field', field: key, from: childRef})\n    applyTemplate('combineField', childRef, linkNode)\n  })\n\n  store.defaultShape = obj\n  addRefOp(storeStateRef, {\n    type: MAP,\n    from: rawShape,\n    fn,\n  })\n  if (!readTemplate()) {\n    store.defaultState = fn\n      ? (storeStateRef.current = fn(stateNew))\n      : defaultState\n  }\n  return store\n}\n\nexport function createStoreObject(...args: any[]) {\n  deprecate(false, 'createStoreObject', 'combine')\n  return combine(...args)\n}\n","import type {Defer} from './unit.h'\n\nexport function createDefer(): Defer {\n  const result = {} as Defer\n  result.req = new Promise((rs, rj) => {\n    result.rs = rs\n    result.rj = rj\n  })\n  result.req.catch(() => {})\n  return result\n}\n","import type {Unit, Stack} from './index.h'\nimport type {Effect, Scope} from './unit.h'\nimport {calc, run} from './step'\nimport {getForkPage, getGraph, getMeta, getParent, setMeta} from './getter'\nimport {own} from './own'\nimport {createNode} from './createNode'\nimport {launch, setForkPage, forkPage, isWatch} from './kernel'\nimport {createStore, createEvent} from './createUnit'\nimport {createDefer} from './defer'\nimport {isObject, isFunction} from './is'\nimport {assert} from './throw'\nimport {EFFECT} from './tag'\nimport {add, removeItem} from './collection'\nimport {flattenConfig} from './config'\nimport {nextEffectID} from './id'\n\ntype RunnerData<Params, Done, Fail> = {\n  params: Params\n  req: {\n    rs(data: Done): void\n    rj(data: Fail): void\n  }\n  args?: [params: Params, computedParams: any] | [params: Params]\n  handler?: Function\n}\n\nexport function createEffect<Params, Done, Fail = Error>(\n  nameOrConfig: any,\n  maybeConfig: any = {},\n): Effect<Params, Done, Fail> {\n  const config = flattenConfig(\n    isFunction(nameOrConfig) ? {handler: nameOrConfig} : nameOrConfig,\n    maybeConfig,\n  )\n  const instance = createEvent(\n    isFunction(nameOrConfig) ? {handler: nameOrConfig} : nameOrConfig,\n    {...maybeConfig, actualOp: EFFECT},\n  ) as unknown as Effect<Params, Done, Fail>\n  const node = getGraph(instance)\n  setMeta(node, 'op', (instance.kind = EFFECT))\n  //@ts-expect-error\n  instance.use = (fn: Function) => {\n    assert(isFunction(fn), '.use argument should be a function')\n    runner.scope.handler = fn\n    return instance\n  }\n  instance.use.getCurrent = () => runner.scope.handler\n  const anyway = (instance.finally = createEvent({\n    named: 'finally',\n    derived: true,\n  }))\n  const done = (instance.done = (anyway as any).filterMap({\n    named: 'done',\n    fn({\n      status,\n      params,\n      result,\n    }: {\n      status: 'done' | 'fail'\n      params: Params\n      result: Done\n      error: Fail\n    }) {\n      if (status === 'done') return {params, result}\n    },\n  }))\n  const fail = (instance.fail = (anyway as any).filterMap({\n    named: 'fail',\n    fn({\n      status,\n      params,\n      error,\n    }: {\n      status: 'done' | 'fail'\n      params: Params\n      result: Done\n      error: Fail\n    }) {\n      if (status === 'fail') return {params, error}\n    },\n  }))\n  const doneData = (instance.doneData = done.map({\n    named: 'doneData',\n    fn: ({result}: {result: Done}) => result,\n  }))\n  const failData = (instance.failData = fail.map({\n    named: 'failData',\n    fn: ({error}: {error: Fail}) => error,\n  }))\n\n  const runner = createNode({\n    scope: {\n      handler:\n        instance.defaultConfig.handler ||\n        (() => assert(false, `no handler used in ${instance.getType()}`)),\n    },\n    node: [\n      calc(\n        (upd: RunnerData<Params, Done, Fail>, scope_: any, stack) => {\n          let handler: Function = scope_.handler\n          const scope = getForkPage(stack)\n          if (scope) {\n            const scopeHandler =\n              scope.handlers.unitMap.get(instance) ||\n              scope.handlers.sidMap[instance.sid!]\n            if (scopeHandler) handler = scopeHandler\n          }\n          upd.handler = handler\n          return upd\n        },\n        false,\n        true,\n      ),\n      calc(\n        (\n          {\n            params,\n            req,\n            handler,\n            args = [params],\n          }: RunnerData<Params, Done, Fail> & {handler: Function},\n          _,\n          stack,\n        ) => {\n          const scopeRef = createScopeRef(stack)\n          const onResolve = onSettled(\n            params,\n            req,\n            true,\n            anyway,\n            stack,\n            scopeRef,\n          )\n          const onReject = onSettled(\n            params,\n            req,\n            false,\n            anyway,\n            stack,\n            scopeRef,\n          )\n          const [ok, result] = runFn(handler, onReject, args)\n          if (ok) {\n            if (isObject(result) && isFunction(result.then)) {\n              result.then(onResolve, onReject)\n            } else {\n              onResolve(result)\n            }\n          }\n        },\n        false,\n        true,\n      ),\n    ],\n    meta: {op: 'fx', fx: 'runner'},\n  })\n  node.scope.runner = runner\n  add(\n    node.seq,\n    calc(\n      (params, {runner}, stack) => {\n        const upd: RunnerData<Params, Done, Fail> = getParent(stack)\n          ? {params, req: {rs(data: Done) {}, rj(data: Fail) {}}}\n          : /** empty stack means that this node was launched directly */\n            params\n        if (!stack.meta) {\n          stack.meta = {fxID: nextEffectID()}\n        }\n        launch({\n          target: runner,\n          params: upd,\n          defer: true,\n          scope: getForkPage(stack),\n          meta: stack.meta,\n        })\n        return upd.params\n      },\n      false,\n      true,\n    ),\n  )\n  //@ts-expect-error\n  instance.create = (params: Params) => {\n    const req = createDefer()\n    const payload = {params, req}\n    if (forkPage) {\n      if (!isWatch) {\n        const savedFork = forkPage\n        req.req\n          .finally(() => {\n            setForkPage(savedFork)\n          })\n          .catch(() => {})\n      }\n    }\n    launch({\n      target: instance,\n      params: payload,\n      scope: forkPage,\n    })\n    return req.req\n  }\n\n  const inFlight = (instance.inFlight = createStore(0, {\n    serialize: 'ignore',\n    named: (getMeta(instance, 'name') || instance.graphite.id) + '.inFlight',\n  })\n    .on(instance, x => x + 1)\n    .on(anyway, x => x - 1)\n    .map({\n      // @ts-expect-error\n      fn: x => x,\n      named: 'inFlight',\n    }))\n  setMeta(anyway, 'needFxCounter', 'dec')\n  setMeta(instance, 'needFxCounter', true)\n  const pending = (instance.pending = inFlight.map({\n    //@ts-expect-error\n    fn: amount => amount > 0,\n    named: 'pending',\n  }))\n\n  own(instance, [anyway, done, fail, doneData, failData, pending, inFlight])\n  if (config?.domain) {\n    config.domain.hooks.effect(instance)\n  }\n  return instance\n}\nexport const runFn = (\n  fn: Function,\n  onReject: (data: any) => void,\n  args: any[],\n): [boolean, any] => {\n  try {\n    return [true, fn(...args)]\n  } catch (err) {\n    onReject(err)\n    return [false, null]\n  }\n}\n\nexport const createScopeRef = (stack: Stack) => {\n  const scope = getForkPage(stack)\n  const scopeRef = {ref: scope}\n  if (scope) add(scope.activeEffects, scopeRef)\n  return scopeRef\n}\n\nexport const onSettled =\n  (\n    params: any,\n    req: {\n      rs(_: any): void\n      rj(_: any): void\n    },\n    ok: boolean,\n    anyway: Unit,\n    stack: Stack,\n    scopeRef: {ref: Scope | void},\n  ) =>\n  (data: any) => {\n    if (scopeRef.ref) removeItem(scopeRef.ref.activeEffects, scopeRef)\n    launch({\n      target: [anyway, sidechain],\n      params: [\n        ok\n          ? {status: 'done', params, result: data}\n          : {status: 'fail', params, error: data},\n        {value: data, fn: ok ? req.rs : req.rj},\n      ],\n      defer: true,\n      // WARN! Will broke forest pages as they arent moved to new scope\n      page: stack.page,\n      scope: scopeRef.ref,\n      meta: stack.meta,\n    })\n  }\nconst sidechain = createNode({\n  node: [run({fn: ({fn, value}) => fn(value)})],\n  meta: {op: 'fx', fx: 'sidechain'},\n})\n","import type {Store, Event, Effect} from './unit.h'\nimport {createEvent} from './createUnit'\nimport {createLinkNode} from './forward'\nimport {unitObjectName} from './naming'\nimport {assertNodeSet} from './is'\n\nexport function merge<T>(\n  units: Array<Event<T> | Store<T> | Effect<T, any, any>>,\n  config?: object,\n): Event<T> {\n  assertNodeSet(units, 'merge', 'first argument')\n  const result = createEvent({\n    name: unitObjectName(units, 'merge'),\n    derived: true,\n    and: config,\n  })\n  createLinkNode(units, result, [], 'merge')\n  return result\n}\n","import type {Cmd, StateRef} from './index.h'\nimport type {CommonUnit, DataCarrier} from './unit.h'\nimport {combine} from './combine'\nimport {mov, userFnCall, read, calc} from './step'\nimport {createStateRef, readRef} from './stateRef'\nimport {callStackAReg} from './caller'\nimport {processArgsToConfig} from './config'\nimport {getStoreState, getGraph} from './getter'\nimport {\n  assertNodeSet,\n  assertTarget,\n  is,\n  isObject,\n  isVoid,\n  isFunction,\n} from './is'\nimport {createStore} from './createUnit'\nimport {createEvent} from './createUnit'\nimport {createNode} from './createNode'\nimport {assert} from './throw'\nimport {forEach} from './collection'\nimport {SAMPLE, STACK, VALUE} from './tag'\nimport {merge} from './merge'\nimport {applyTemplate} from './template'\nimport {own} from './own'\nimport {createLinkNode} from './forward'\n\nconst sampleConfigFields = ['source', 'clock', 'target']\n\nconst fieldErrorMessage = (method: string, field: string) =>\n  method + `: ${field} should be defined`\n\nexport function validateSampleConfig(config: any, method: string) {\n  let atLeastOneFieldExists = false\n  forEach(sampleConfigFields, field => {\n    if (field in config) {\n      assert(config[field] != null, fieldErrorMessage(method, field))\n      atLeastOneFieldExists = true\n    }\n  })\n  return atLeastOneFieldExists\n}\n\nexport function sample(...args: any[]) {\n  let target\n  let name\n  let [[source, clock, fn], metadata] = processArgsToConfig(args)\n  let sid\n  let batched = true\n  let filter\n  /** config case */\n  if (\n    isVoid(clock) &&\n    isObject(source) &&\n    validateSampleConfig(source, SAMPLE)\n  ) {\n    clock = source.clock\n    fn = source.fn\n    batched = !source.greedy\n    filter = source.filter\n    /** optional target & name accepted only from config */\n    target = source.target\n    name = source.name\n    sid = source.sid\n    source = source.source\n  }\n  return createSampling(\n    SAMPLE,\n    clock,\n    source,\n    filter,\n    target,\n    fn,\n    name,\n    metadata,\n    batched,\n    true,\n    false,\n    sid,\n  )\n}\n\nexport const createSampling = (\n  method: string,\n  clock: DataCarrier | DataCarrier[] | void,\n  source: DataCarrier | Array<Store<any>> | Record<string, Store<any>> | void,\n  filter: any,\n  target: DataCarrier | DataCarrier[] | void,\n  fn: any,\n  name: string | undefined,\n  metadata: object | void,\n  batched: boolean,\n  targetMayBeStore: boolean,\n  filterRequired: boolean,\n  sid?: string | undefined,\n) => {\n  const isUpward = !!target\n  assert(\n    !isVoid(source) || !isVoid(clock),\n    fieldErrorMessage(method, 'either source or clock'),\n  )\n  let sourceIsClock = false\n  if (isVoid(source)) {\n    sourceIsClock = true\n  } else if (!is.unit(source)) {\n    source = combine(source)\n  }\n  if (isVoid(clock)) {\n    /** still undefined! */\n    clock = source\n  } else {\n    assertNodeSet(clock, method, 'clock')\n    if (Array.isArray(clock)) {\n      clock = merge(clock as CommonUnit[])\n    }\n  }\n  if (sourceIsClock) {\n    source = clock\n  }\n  // @ts-expect-error\n  if (!metadata && !name) name = source.shortName\n  let filterType: 'none' | 'unit' | 'fn' = 'none'\n  if (filterRequired || filter) {\n    if (is.unit(filter)) {\n      filterType = 'unit'\n    } else {\n      assert(isFunction(filter), '`filter` should be function or unit')\n      filterType = 'fn'\n    }\n  }\n  if (target) {\n    assertNodeSet(target, method, 'target')\n    assertTarget(method, target)\n  } else {\n    if (\n      filterType === 'none' &&\n      targetMayBeStore &&\n      is.store(source) &&\n      is.store(clock)\n    ) {\n      const initialState = fn\n        ? fn(readRef(getStoreState(source)), readRef(getStoreState(clock)))\n        : readRef(getStoreState(source))\n      // @ts-expect-error\n      target = createStore(initialState, {name, sid, or: metadata})\n    } else {\n      target = createEvent({name, derived: true, or: metadata})\n      applyTemplate('sampleTarget', getGraph(target))\n    }\n  }\n  // const targetTemplate =\n  //   isUpward && is.unit(target) && getGraph(target).meta.nativeTemplate\n  const clockState = createStateRef()\n  let filterNodes: Cmd[] = []\n  if (filterType === 'unit') {\n    const [filterRef, hasFilter] = syncSourceState(\n      filter as DataCarrier,\n      target,\n      // @ts-expect-error\n      clock,\n      clockState,\n      method,\n    )\n    filterNodes = [...readAndFilter(hasFilter), ...readAndFilter(filterRef)]\n  }\n  const [sourceRef, hasSource] = syncSourceState(\n    // @ts-expect-error\n    source,\n    target,\n    clock,\n    clockState,\n    method,\n  )\n  const jointNode = createLinkNode(\n    // @ts-expect-error\n    clock,\n    target,\n    [\n      applyTemplate('sampleSourceLoader'),\n      mov({from: STACK, target: clockState}),\n      ...readAndFilter(hasSource),\n      read(sourceRef, true, batched),\n      ...filterNodes,\n      read(clockState),\n      filterType === 'fn' && userFnCall((src, _, {a}) => filter(src, a), true),\n      fn && userFnCall(callStackAReg),\n      applyTemplate('sampleSourceUpward', isUpward),\n    ],\n    method,\n    fn,\n  )\n  // @ts-expect-error\n  own(source, [jointNode])\n  Object.assign(jointNode.meta, metadata, {joint: true})\n  return target\n}\n\nconst readAndFilter = (state: StateRef) => [\n  read(state),\n  calc((upd, scope, {a}) => a, true),\n]\n\nconst syncSourceState = (\n  source: DataCarrier,\n  target: DataCarrier | DataCarrier[],\n  clock: DataCarrier | DataCarrier[],\n  clockState: StateRef,\n  method: string,\n) => {\n  const isSourceStore = is.store(source)\n  const sourceRef = isSourceStore ? getStoreState(source) : createStateRef()\n  const hasSource = createStateRef(isSourceStore)\n  if (!isSourceStore) {\n    createNode({\n      parent: source,\n      node: [\n        mov({from: STACK, target: sourceRef}),\n        mov({from: VALUE, store: true, target: hasSource}),\n      ],\n      family: {owners: [source, target, clock], links: target},\n      meta: {op: method},\n      regional: true,\n    })\n  }\n  applyTemplate('sampleSource', hasSource, sourceRef, clockState)\n  return [sourceRef, hasSource] as const\n}\n","import {getMeta, getOwners, getLinks} from '../getter'\nimport {is} from '../is'\nimport {assert} from '../throw'\nimport type {Store, Effect, ValuesMap, HandlersMap} from '../unit.h'\nimport type {Node, Unit} from '../index.h'\nimport {add, forEach, includes} from '../collection'\nimport {STORE} from '../tag'\n\nexport function traverseStores(\n  root: Node,\n  fn: (node: Node, sid: string | null) => void,\n  needSidlessStores: true,\n): void\nexport function traverseStores(\n  root: Node,\n  fn: (node: Node, sid: string) => void,\n): void\nexport function traverseStores(\n  root: Node,\n  fn: (node: Node, sid: string) => void,\n  needSidlessStores?: boolean,\n) {\n  const list = [] as Node[]\n  ;(function visit(node) {\n    if (includes(list, node)) return\n    add(list, node)\n    if (getMeta(node, 'op') === STORE) {\n      if (needSidlessStores || getMeta(node, 'sid')) {\n        fn(node, getMeta(node, 'sid'))\n      }\n    }\n    forEach(node.next, visit)\n    forEach(getOwners(node), visit)\n    forEach(getLinks(node), visit)\n  })(root)\n}\n\ntype StoreOrEffect = Store<any> | Effect<any, any, any>\n\nexport function normalizeValues(\n  values: ValuesMap | HandlersMap,\n  assertEach?: (key: StoreOrEffect, value: any) => void,\n) {\n  const mapOrRecordValues: Map<StoreOrEffect, any> | Record<string, any> =\n    Array.isArray(values) ? new Map(values as [StoreOrEffect, any][]) : values\n  const unitMap = new Map<Unit<any>, any>()\n  let hasSidDoubles = false\n  if (mapOrRecordValues instanceof Map) {\n    const sidMap = {} as Record<string, any>\n    forEach(mapOrRecordValues, (value, key) => {\n      assert(\n        (is.unit as (val: unknown) => val is StoreOrEffect)(key),\n        'Map key should be a unit',\n      )\n      if (assertEach) assertEach(key, value)\n      if (key.sid) {\n        if (key.sid in sidMap) hasSidDoubles = true\n        sidMap[key.sid!] = value\n      }\n      unitMap.set(key, value)\n    })\n    return {sidMap, unitMap, hasSidDoubles}\n  }\n  return {sidMap: mapOrRecordValues, unitMap}\n}\n","import {clearNode} from './clearNode'\nimport {createNode} from './createNode'\nimport type {Node, Subscription, Unit} from './index.h'\nimport {step} from './step'\nimport {Scope} from './unit.h'\n\nexport function createWatch<T>({\n  unit,\n  fn,\n  scope,\n}: {\n  unit: Unit<T>\n  fn: (value: T) => any\n  scope?: Scope\n}): Subscription {\n  const seq = [step.run({fn: value => fn(value)})]\n  if (scope) {\n    const node = createNode({node: seq})\n    const id = (unit as any).graphite.id\n    const scopeLinks: {[_: string]: Node[]} = (scope as any).additionalLinks\n    const links = scopeLinks[id] || []\n    scopeLinks[id] = links\n    links.push(node)\n    return createSubscription(() => {\n      const idx = links.indexOf(node)\n      if (idx !== -1) links.splice(idx, 1)\n      clearNode(node)\n    })\n  } else {\n    const node = createNode({\n      node: seq,\n      parent: [unit],\n      family: {owners: unit},\n    })\n    return createSubscription(() => {\n      clearNode(node)\n    })\n  }\n}\n\nfunction createSubscription(callback: () => void): Subscription {\n  const subscription: Subscription = () => callback()\n  subscription.unsubscribe = () => callback()\n\n  return subscription\n}\n","export const observableSymbol =\n  (typeof Symbol !== 'undefined' && Symbol.observable) || '@@observable'\n","import type {Node, StateRef, NodeUnit} from './index.h'\nimport type {Scope, Store, CommonUnit, Domain} from './unit.h'\n\nexport const getGraph = (graph: NodeUnit): Node =>\n  (graph as {graphite: Node}).graphite || graph\nexport const getOwners = (node: Node) => node.family.owners\nexport const getLinks = (node: Node) => node.family.links\nexport const getStoreState = (store: Store<any>): StateRef => store.stateRef\nexport const getValue = (stack: any) => stack.value\nexport const getSubscribers = (store: Store<any>) => store.subscribers\nexport const getParent = (unit: any) => unit.parent\nexport const getForkPage = (val: any): Scope | void => val.scope\nexport const getMeta = (unit: NodeUnit, field: string) =>\n  getGraph(unit).meta[field]\nexport const setMeta = (unit: NodeUnit, field: string, value: unknown) =>\n  (getGraph(unit).meta[field] = value)\nexport const getCompositeName = (unit: CommonUnit | Domain) =>\n  unit.compositeName\n","import type {Kind, Unit} from './index.h'\nimport type {Domain, Effect, Event, Scope, Store} from './unit.h'\nimport {DOMAIN, STORE, EVENT, EFFECT, SCOPE} from './tag'\nimport {isObject, isFunction} from './is'\nimport {getMeta} from './getter'\n\nexport const unit = (obj: unknown): obj is Unit<any> =>\n  (isFunction(obj) || isObject(obj)) && 'kind' in obj\n\nconst is = (type: Kind) => (obj: unknown) => unit(obj) && obj.kind === type\n\nexport const store = is(STORE) as (value: unknown) => value is Store<unknown>\nexport const event = is(EVENT) as (value: unknown) => value is Event<unknown>\nexport const effect = is(EFFECT) as (\n  value: unknown,\n) => value is Effect<unknown, unknown, unknown>\nexport const domain = is(DOMAIN) as (value: unknown) => value is Domain\nexport const scope = is(SCOPE) as (value: unknown) => value is Scope\nexport const attached = (unit: unknown) =>\n  effect(unit) && getMeta(unit, 'attached') === true\n","const idCount = () => {\n  let id = 0\n  return () => `${++id}`\n}\n\nexport const nextUnitID = idCount()\nexport const nextStepID = idCount()\nexport const nextNodeID = idCount()\nexport const nextEffectID = idCount()\n","import type {NodeUnit} from './index.h'\nimport {getGraph, getOwners, getLinks} from './getter'\nimport {DOMAIN, CROSSLINK} from './tag'\nimport {add, forEach} from './collection'\n\nexport const own = (ownerUnit: NodeUnit, links: NodeUnit[]) => {\n  const owner = getGraph(ownerUnit)\n  forEach(links, _link => {\n    const link = getGraph(_link)\n    if (owner.family.type !== DOMAIN) link.family.type = CROSSLINK\n    add(getOwners(link), owner)\n    add(getLinks(owner), link)\n  })\n}\n","export * as is from './validate'\nimport {forEach} from './collection'\nimport {assert, deprecate} from './throw'\nimport {arrifyNodes} from './createNode'\nimport type {NodeUnit} from './index.h'\nimport type {DataCarrier} from './unit.h'\nimport {getMeta} from './getter'\n\nexport const isObject = (value: unknown): value is Record<any, any> =>\n  typeof value === 'object' && value !== null\nexport const isFunction = (value: unknown): value is Function =>\n  typeof value === 'function'\n\nexport const isVoid = (value: unknown): value is void => value === undefined\n\nexport const assertObject = (value: unknown) =>\n  assert(\n    isObject(value) || isFunction(value),\n    'expect first argument be an object',\n  ) // or function\n\nconst assertNodeSetItem = (\n  value: unknown,\n  method: string,\n  valueName: string,\n  reason: string,\n): asserts value is DataCarrier =>\n  assert(\n    !(\n      (!isObject(value) && !isFunction(value)) ||\n      (!('family' in value) && !('graphite' in value))\n    ),\n    `${method}: expect ${valueName} to be a unit (store, event or effect)${reason}`,\n  )\n\nexport const assertNodeSet = (\n  value: unknown,\n  method: string,\n  valueName: string,\n) => {\n  if (Array.isArray(value)) {\n    forEach(value, (item, i) =>\n      assertNodeSetItem(item, method, `${i} item of ${valueName}`, ''),\n    )\n  } else {\n    //@ts-expect-error some ts assertion edge case\n    assertNodeSetItem(value, method, valueName, ' or array of units')\n  }\n}\n\nexport const assertTarget = (\n  method: string,\n  target: NodeUnit | NodeUnit[],\n  targetField: string = 'target',\n) =>\n  forEach(arrifyNodes(target), item =>\n    deprecate(\n      !getMeta(item, 'derived'),\n      `${method}: derived unit in \"${targetField}\"`,\n      `createEvent/createStore`,\n    ),\n  )\n","import type {Stack} from './index.h'\n\nexport const callStackAReg = (\n  stack: any,\n  {fn}: {[key: string]: any},\n  {a}: Stack,\n) => fn(stack, a)\nexport const callARegStack = (\n  stack: any,\n  {fn}: {[key: string]: any},\n  {a}: Stack,\n) => fn(a, stack)\nexport const callStack = (stack: any, {fn}: {[key: string]: any}, _: Stack) =>\n  fn(stack)\n","import type {\n  StateRef,\n  Compute,\n  MovValueToRegister,\n  MovValueToStore,\n  MovStoreToRegister,\n  MovStoreToStore,\n  MovRegisterToStore,\n  Stack,\n} from './index.h'\nimport {nextStepID} from './id'\nimport {EFFECT, REG_A, SAMPLER, STACK, STORE} from './tag'\nimport type {BarrierPriorityTag} from './kernel'\nimport {callStack} from './caller'\n\nconst cmd = <Type extends 'compute' | 'mov'>(\n  type: Type,\n  data: any,\n  priority?: BarrierPriorityTag | false,\n  batch?: boolean,\n) => {\n  const result: {\n    id: string\n    type: Type\n    data: any\n    order?: {\n      priority: BarrierPriorityTag\n      barrierID?: number\n    }\n  } = {\n    id: nextStepID(),\n    type,\n    data,\n  }\n  if (priority) {\n    result.order = {priority}\n    if (batch) result.order.barrierID = ++nextBarrierID\n  }\n  return result\n}\n\nlet nextBarrierID = 0\n\nexport const mov: {\n  <T>(data: {\n    from: 'value'\n    store: T\n    target: StateRef\n    batch?: boolean\n    priority?: BarrierPriorityTag\n  }): MovValueToStore<T>\n  <T>(data: {\n    from: 'value'\n    to: 'stack' | 'a' | 'b'\n    store: T\n    batch?: boolean\n    priority?: BarrierPriorityTag\n  }): MovValueToRegister<T>\n  (data: {\n    from: 'a' | 'b' | 'stack'\n    target: StateRef\n    batch?: boolean\n    priority?: BarrierPriorityTag\n  }): MovRegisterToStore\n  (data: {\n    from: 'a' | 'b' | 'stack'\n    to: 'a' | 'b' | 'stack'\n    batch?: boolean\n    priority?: BarrierPriorityTag\n  }): MovRegisterToStore\n  (data: {\n    store: StateRef\n    target: StateRef\n    batch?: boolean\n    priority?: BarrierPriorityTag\n  }): MovStoreToStore\n  (data: {\n    store: StateRef\n    to: 'stack' | 'a' | 'b'\n    batch?: boolean\n    priority?: BarrierPriorityTag | false\n  }): MovStoreToRegister\n  (data: {\n    store: StateRef\n    batch?: boolean\n    priority?: BarrierPriorityTag | false\n  }): MovStoreToRegister\n  // (data: {\n  //   from?: 'value' | 'store' | 'stack' | 'a' | 'b'\n  //   to?: 'stack' | 'a' | 'b' | 'store'\n  //   store?: StateRef\n  //   target?: StateRef\n  // }): Mov\n} = ({\n  from = STORE,\n  store,\n  target,\n  to = target ? STORE : STACK,\n  batch,\n  priority,\n}: {\n  from?: 'value' | 'store' | 'stack' | 'a' | 'b'\n  to?: 'stack' | 'a' | 'b' | 'store'\n  store?: StateRef\n  target?: StateRef\n  batch?: boolean\n  priority?: BarrierPriorityTag | false\n}) => cmd('mov', {from, store, to, target}, priority, batch)\n\nexport const compute = <\n  LocalValues extends {[key: string]: any} = {[key: string]: any},\n>({\n  fn,\n  batch,\n  priority,\n  safe = false,\n  filter = false,\n  pure = false,\n}: {\n  fn?: (data: any, scope: LocalValues, stack: Stack) => any\n  batch?: boolean\n  priority?: BarrierPriorityTag | false\n  safe?: boolean\n  filter?: boolean\n  pure?: boolean\n}): Compute => cmd('compute', {fn, safe, filter, pure}, priority, batch)\n\nexport const filter = ({\n  fn,\n  pure,\n}: {\n  fn(data: any, scope: {[key: string]: any}, stack: Stack): any\n  pure?: boolean\n}) => compute({fn, filter: true, pure})\n\nexport const run = ({\n  fn,\n}: {\n  fn(data: any, scope: {[key: string]: any}, stack: Stack): any\n}) => compute({fn, priority: EFFECT})\n\nexport const calc = <\n  LocalValues extends {[key: string]: any} = {[key: string]: any},\n>(\n  fn: (data: any, scope: LocalValues, stack: Stack) => any,\n  filter?: boolean,\n  isEffect?: boolean,\n) => compute({fn, safe: true, filter, priority: isEffect && EFFECT})\n\n/**\n * `read(ref, true, true)`: **reg.stack** with **sampler** batch\n *\n * `read(ref, true, false)`: **reg.stack** without batch\n *\n * `read(ref, false, true)`: **reg.a** with **sampler** batch\n *\n * `read(ref, false, false)`: **reg.a** without batch\n *\n */\nexport const read = (\n  store: StateRef,\n  toStack?: boolean,\n  samplerPriority?: boolean,\n) =>\n  mov({\n    store,\n    to: toStack ? STACK : REG_A,\n    priority: samplerPriority && SAMPLER,\n    batch: true,\n  })\n\nexport const userFnCall = (\n  fn: (data: any, scope: {[key: string]: any}, stack: Stack) => any = callStack,\n  isFilter?: boolean,\n) => compute({fn, pure: true, filter: isFilter})\n\nexport const step = {mov, compute, filter, run}\n","import type {StateRef, StateRefOp} from './index.h'\nimport {nextStepID} from './id'\nimport {add} from './collection'\n\nexport const createStateRef = (current?: any): StateRef => ({\n  id: nextStepID(),\n  current,\n})\nexport const readRef = ({current}: StateRef | {current: any}) => current\n\nexport const addRefOp = (ref: StateRef, op: StateRefOp) => {\n  if (!ref.before) ref.before = []\n  add(ref.before!, op as any)\n}\n","import {Node, NodeUnit} from './index.h'\nimport {getGraph, getOwners, getLinks, getSubscribers, getMeta} from './getter'\nimport {is} from './is'\nimport {removeItem} from './collection'\nimport {CROSSLINK} from './tag'\n\nconst removeFromNode = (currentNode: Node, targetNode: Node) => {\n  removeItem(currentNode.next, targetNode)\n  removeItem(getOwners(currentNode), targetNode)\n  removeItem(getLinks(currentNode), targetNode)\n}\nconst clearNodeNormalized = (\n  targetNode: Node,\n  deep: boolean,\n  isDomainUnit: boolean,\n) => {\n  targetNode.next.length = 0\n  targetNode.seq.length = 0\n  //@ts-expect-error\n  targetNode.scope = null\n  let currentNode\n  let list = getLinks(targetNode)\n  while ((currentNode = list.pop())) {\n    removeFromNode(currentNode, targetNode)\n    if (\n      deep ||\n      (isDomainUnit && getMeta(targetNode, 'op') !== 'sample') ||\n      currentNode.family.type === CROSSLINK\n    ) {\n      clearNodeNormalized(\n        currentNode,\n        deep,\n        getMeta(currentNode, 'op') !== 'on' && isDomainUnit,\n      )\n    }\n  }\n  list = getOwners(targetNode)\n  while ((currentNode = list.pop())) {\n    removeFromNode(currentNode, targetNode)\n    if (isDomainUnit && currentNode.family.type === CROSSLINK) {\n      clearNodeNormalized(\n        currentNode,\n        deep,\n        getMeta(currentNode, 'op') !== 'on' && isDomainUnit,\n      )\n    }\n  }\n}\nconst clearMap = (map: Map<any, any> | Set<any>) => map.clear()\nexport const clearNode = (\n  graphite: NodeUnit,\n  {\n    deep,\n  }: {\n    deep?: boolean\n  } = {},\n) => {\n  let isDomainUnit = false\n  //@ts-expect-error\n  if (graphite.ownerSet) graphite.ownerSet.delete(graphite)\n  if (is.store(graphite)) {\n    clearMap(getSubscribers(graphite))\n  } else if (is.domain(graphite)) {\n    isDomainUnit = true\n    const history = graphite.history\n    clearMap(history.events)\n    clearMap(history.effects)\n    clearMap(history.stores)\n    clearMap(history.domains)\n  }\n  clearNodeNormalized(getGraph(graphite), !!deep, isDomainUnit)\n}\n","import type {Subscription, NodeUnit} from './index.h'\nimport {clearNode} from './clearNode'\n\nexport const createSubscription = (node: NodeUnit): Subscription => {\n  const result = () => clearNode(node)\n  result.unsubscribe = result\n  return result\n}\n","import {processArgsToConfig} from './config'\nimport {createNode} from './createNode'\nimport type {Subscription, NodeUnit, Cmd} from './index.h'\nimport {createSubscription} from './subscription'\nimport {assertNodeSet, assertTarget} from './is'\n\nexport const createLinkNode = (\n  parent: NodeUnit | NodeUnit[],\n  child: NodeUnit | NodeUnit[],\n  node?: Array<Cmd | false | void | null>,\n  op?: string,\n  scopeFn?: Function,\n) =>\n  createNode({\n    node,\n    parent,\n    child,\n    scope: {fn: scopeFn},\n    meta: {op},\n    family: {owners: [parent, child], links: child},\n    regional: true,\n  })\nexport const forward = (opts: {\n  from: NodeUnit | NodeUnit[]\n  to: NodeUnit | NodeUnit[]\n  meta?: Record<string, any>\n}): Subscription => {\n  const method = 'forward'\n  const [{from, to}, config] = processArgsToConfig(opts, true)\n  assertNodeSet(from, method, '\"from\"')\n  assertNodeSet(to, method, '\"to\"')\n  assertTarget(method, to, 'to')\n  return createSubscription(\n    createNode({\n      parent: from,\n      child: to,\n      meta: {op: method, config},\n      family: {},\n      regional: true,\n    }),\n  )\n}\n","import {run} from './step'\nimport {callStack} from './caller'\nimport {createNode} from './createNode'\nimport {Subscription, NodeUnit} from './index.h'\nimport {createSubscription} from './subscription'\nimport {assert} from './throw'\nimport {isFunction} from './is'\n\nexport const watchUnit = (\n  unit: NodeUnit,\n  handler: (payload: any) => any,\n): Subscription => {\n  assert(isFunction(handler), '.watch argument should be a function')\n  return createSubscription(\n    createNode({\n      scope: {fn: handler},\n      node: [run({fn: callStack})],\n      parent: unit,\n      meta: {op: 'watch'},\n      family: {owners: unit},\n      regional: true,\n    }),\n  )\n}\n","import type {DataCarrier} from './unit.h'\nimport type {Cmd, Stack} from './index.h'\nimport {is, isFunction, isObject, assertTarget} from './is'\nimport {add, forIn, includes} from './collection'\nimport {addRefOp, createStateRef} from './stateRef'\nimport {createLinkNode} from './forward'\nimport {processArgsToConfig} from './config'\nimport {compute, userFnCall, calc, read} from './step'\nimport {createNode} from './createNode'\nimport {launch} from './kernel'\nimport {getStoreState} from './getter'\nimport {assert} from './throw'\nimport {createEvent} from './createUnit'\nimport {applyTemplate} from './template'\nimport {createSampling} from './sample'\n\nconst launchCase = (\n  scopeTargets: Record<string, DataCarrier>,\n  field: string,\n  data: any,\n  stack: Stack,\n) => {\n  const target = scopeTargets[field]\n  if (target) {\n    launch({\n      target,\n      params: Array.isArray(target) ? target.map(() => data) : data,\n      defer: true,\n      stack,\n    })\n  }\n}\n\nexport function split(...args: any[]) {\n  const METHOD = 'split'\n  let targets: Record<string, DataCarrier>\n  let clock: void | DataCarrier | DataCarrier[]\n  let [[source, match], metadata] = processArgsToConfig(args)\n  const configForm = !match\n  if (configForm) {\n    targets = source.cases\n    match = source.match\n    clock = source.clock\n    source = source.source\n  }\n  const matchIsUnit = is.store(match)\n  const matchIsFunction = !is.unit(match) && isFunction(match)\n  const matchIsShape = !matchIsUnit && !matchIsFunction && isObject(match)\n  assert(is.unit(source), 'source must be a unit')\n  if (!targets!) targets = {}\n  if (!configForm) {\n    assert(matchIsShape, 'match should be an object')\n    forIn(\n      match,\n      (_, key) =>\n        (targets[key] = createEvent({\n          derived: true,\n          named: `cases.${key}`,\n          and: metadata,\n        })),\n    )\n    targets.__ = createEvent({\n      derived: true,\n      named: 'cases.__',\n      and: metadata,\n    })\n  } else {\n    forIn(targets, (target, field) =>\n      assertTarget(METHOD, target, `cases.${field}`),\n    )\n  }\n  const owners = new Set(\n    ([] as DataCarrier[]).concat(source, clock || [], Object.values(targets)),\n  )\n  const caseNames = Object.keys(\n    matchIsUnit || matchIsFunction ? targets : match,\n  )\n  let splitterSeq: Array<Cmd | false>\n  if (matchIsUnit || matchIsFunction) {\n    if (matchIsUnit) owners.add(match)\n    splitterSeq = [\n      matchIsUnit && read(getStoreState(match), false, true),\n      compute({\n        safe: matchIsUnit,\n        filter: true,\n        pure: !matchIsUnit,\n        fn(data, scopeTargets, stack) {\n          const value = String(matchIsUnit ? stack.a : match(data))\n          launchCase(\n            scopeTargets,\n            includes(caseNames, value) ? value : '__',\n            data,\n            stack,\n          )\n        },\n      }),\n    ]\n  } else if (matchIsShape) {\n    const lastValues = createStateRef({})\n    lastValues.type = 'shape'\n    const units = [] as string[]\n    let needBarrier: boolean\n    forIn(match, (storeOrFn, key) => {\n      if (is.unit(storeOrFn)) {\n        needBarrier = true\n        add(units, key)\n        // @ts-expect-error\n        owners.add(storeOrFn)\n        const updater = createLinkNode(\n          storeOrFn,\n          [],\n          [read(lastValues), calc((upd, _, {a}) => (a[key] = upd))],\n        )\n        if (is.store(storeOrFn)) {\n          lastValues.current[key] = storeOrFn.getState()\n          const storeRef = getStoreState(storeOrFn)\n          addRefOp(lastValues, {from: storeRef, field: key, type: 'field'})\n          applyTemplate('splitMatchStore', storeRef, updater)\n        }\n      }\n    })\n    if (needBarrier!) {\n      applyTemplate('splitBase', lastValues)\n    }\n    splitterSeq = [\n      needBarrier! && read(lastValues, false, true),\n      userFnCall((data, scopeTargets, stack) => {\n        for (let i = 0; i < caseNames.length; i++) {\n          const caseName = caseNames[i]\n          const caseValue = includes(units, caseName)\n            ? stack.a[caseName]\n            : match[caseName](data)\n          if (caseValue) {\n            launchCase(scopeTargets, caseName, data, stack)\n            return\n          }\n        }\n        launchCase(scopeTargets, '__', data, stack)\n      }, true),\n    ]\n  } else {\n    assert(false, 'expect match to be unit, function or object')\n  }\n  const splitterNode = createNode({\n    meta: {op: METHOD},\n    parent: clock ? [] : source,\n    scope: targets,\n    node: splitterSeq!,\n    family: {owners: Array.from(owners)},\n    regional: true,\n  })\n  if (clock) {\n    createSampling(\n      METHOD,\n      clock,\n      source,\n      null,\n      splitterNode,\n      null,\n      METHOD,\n      metadata,\n      /* non-batched */\n      false,\n      false,\n      false,\n    )\n  }\n  if (!configForm) return targets\n}\n","import type {Scope, Store} from '../unit.h'\nimport {forIn, includes} from '../collection'\nimport {assert} from '../throw'\nimport {traverseStores} from './util'\nimport {getGraph, getMeta} from '../getter'\n\nconst noopSerializer = (x: any) => x\n/**\n serialize state on server\n */\nexport function serialize(\n  scope: Scope,\n  config: {ignore?: Array<Store<any>>; onlyChanges?: boolean} = {},\n) {\n  if (scope.warnSerialize) {\n    console.error(\n      'There is a store without sid in this scope, its value is omitted',\n    )\n  }\n  assert(!scope.hasSidDoubles, 'duplicate sid found in this scope')\n  const ignoredStores = config.ignore ? config.ignore.map(({sid}) => sid) : []\n  const result = {} as Record<string, any>\n  forIn(scope.values.sidMap, (value, sid) => {\n    if (includes(ignoredStores, sid)) return\n    const id = scope.sidIdMap[sid]\n    const serializeSettings = scope.sidSerializeSettings.get(sid) ?? {\n      ignore: false,\n      write: noopSerializer,\n    }\n    if (serializeSettings.ignore) return\n    const serializer = serializeSettings.write\n    // if (!scope.changedStores.has(id)) return\n    if (id && id in scope.reg) {\n      result[sid] = serializer(scope.reg[id].current)\n    } else {\n      result[sid] = serializer(value)\n    }\n  })\n  if ('onlyChanges' in config && !config.onlyChanges) {\n    assert(scope.cloneOf, 'scope should be created from domain')\n    traverseStores(getGraph(scope.cloneOf), (node, sid) => {\n      if (\n        !(sid in result) &&\n        !includes(ignoredStores, sid) &&\n        !getMeta(node, 'isCombine') &&\n        getMeta(node, 'serialize') !== 'ignore'\n      )\n        result[sid] = scope.getState(node as any)\n    })\n  }\n  return result\n}\n","import {add} from '../collection'\nimport {createDefer} from '../defer'\nimport {is} from '../is'\nimport {launch, forkPage} from '../kernel'\nimport type {Scope, Event, Effect, DataCarrier, SettledDefer} from '../unit.h'\n\nexport function allSettled<T>(\n  start: Event<T> | Effect<T, any, any> | Scope,\n  //@ts-expect-error its optional in correct cases\n  {scope, params: ctx}: {scope: Scope; params?: unknown} = {},\n) {\n  if (!is.unit(start))\n    return Promise.reject(new Error('first argument should be unit'))\n  if (\n    !is.effect(start) &&\n    !is.event(start) &&\n    !is.store(start) &&\n    !is.scope(start)\n  )\n    return Promise.reject(\n      new Error(\n        'first argument accepts only effects, events, stores or scopes',\n      ),\n    )\n  /** duplicated check because of ts validation */\n  if (is.scope(start)) {\n    scope = start\n  }\n  const defer = createDefer() as SettledDefer\n  defer.parentFork = forkPage\n  const {fxCount} = scope\n  add(fxCount.scope.defers, defer)\n\n  const launchUnits: DataCarrier[] = []\n  const launchParams: Array<{params: unknown; req: unknown} | null> = []\n  if (!is.scope(start)) {\n    add(launchUnits, start)\n    add(\n      launchParams,\n      is.effect(start)\n        ? {\n            params: ctx,\n            req: {\n              rs(value: unknown) {\n                defer.value = {status: 'done', value}\n              },\n              rj(value: unknown) {\n                defer.value = {status: 'fail', value}\n              },\n            },\n          }\n        : ctx,\n    )\n  }\n  add(launchUnits, fxCount)\n  add(launchParams, null)\n  launch({\n    target: launchUnits,\n    params: launchParams,\n    scope,\n  })\n  return defer.req\n}\n","import type {Domain} from './unit.h'\nimport {combine} from './combine'\nimport {createEffect, createScopeRef, onSettled, runFn} from './createEffect'\nimport {applyParentHook} from './createUnit'\nimport {processArgsToConfig} from './config'\nimport {\n  getGraph,\n  getParent,\n  getStoreState,\n  setMeta,\n  getCompositeName,\n} from './getter'\nimport {own} from './own'\nimport {is} from './is'\nimport {read, calc} from './step'\nimport {launch} from './kernel'\nimport {EFFECT} from './tag'\nimport {createName} from './naming'\n\nexport function attach(config: any) {\n  let injected\n  ;[config, injected] = processArgsToConfig(config, true)\n  let {source, effect, mapParams} = config\n  const attached = createEffect(config, injected)\n  setMeta(attached, 'attached', true)\n  const {runner} = getGraph(attached).scope\n  let runnerSteps\n  const runnerFnStep = calc(\n    (upd, _, stack) => {\n      const {params, req, handler} = upd\n      const anyway = attached.finally\n      const scopeRef = createScopeRef(stack)\n      const rj = onSettled(params, req, false, anyway, stack, scopeRef)\n      const sourceData = stack.a\n      const isEffectHandler = is.effect(handler)\n      let ok = true\n      let computedParams\n      if (mapParams) {\n        ;[ok, computedParams] = runFn(mapParams, rj, [params, sourceData])\n      } else {\n        computedParams = source && isEffectHandler ? sourceData : params\n      }\n      if (ok) {\n        if (isEffectHandler) {\n          launch({\n            target: handler as any,\n            params: {\n              params: computedParams,\n              req: {\n                rs: onSettled(params, req, true, anyway, stack, scopeRef),\n                rj,\n              },\n            },\n            page: stack.page,\n            defer: true,\n            meta: stack.meta,\n          })\n        } else {\n          upd.args = [sourceData, computedParams]\n          return true\n        }\n      }\n    },\n    true,\n    true,\n  )\n  if (source) {\n    let state\n    if (is.store(source)) {\n      state = source\n      own(state, [attached])\n    } else {\n      state = combine(source)\n      own(attached, [state])\n    }\n    runnerSteps = [read(getStoreState(state)), runnerFnStep]\n  } else {\n    runnerSteps = [runnerFnStep]\n  }\n  runner.seq.splice(1, 0, ...runnerSteps)\n  attached.use(effect)\n  const parentDomain: Domain | void = getParent(effect)\n  if (parentDomain) {\n    Object.assign(\n      getCompositeName(attached),\n      createName(attached.shortName, parentDomain),\n    )\n    attached.defaultConfig.parent = parentDomain\n  }\n  applyParentHook(effect, attached, EFFECT)\n  return attached\n}\n","import type {Store, Event} from './unit.h'\nimport {createEvent, applyParentHook} from './createUnit'\nimport {forIn} from './collection'\nimport {getParent} from './getter'\nimport {processArgsToConfig} from './config'\n\nexport function createApi(...args: [Store<any>, {[key: string]: Function}]) {\n  let [[store, setters], metadata] = processArgsToConfig(args)\n  const result: Record<string, Event<any>> = {}\n  forIn(setters, (fn, key) => {\n    const event = (result[key] = createEvent(key, {\n      parent: getParent(store),\n      config: metadata,\n    }))\n    store.on(event, fn)\n    applyParentHook(store, event)\n  })\n  return result\n}\n","import type {Domain} from './unit.h'\nimport {own} from './own'\nimport {createNode} from './createNode'\nimport type {Config, NodeUnit} from './index.h'\nimport {\n  createEvent,\n  createNamedEvent,\n  createStore,\n  initUnit,\n} from './createUnit'\nimport {createEffect} from './createEffect'\nimport {createLinkNode} from './forward'\nimport {add, forEach, forIn} from './collection'\nimport {getGraph, getParent} from './getter'\nimport {DOMAIN} from './tag'\nimport {launch} from './kernel'\nimport {calc} from './step'\nimport {flattenConfig} from './config'\n\nexport function createDomain(nameOrConfig: any, maybeConfig?: any): Domain {\n  const config = flattenConfig({\n    or: maybeConfig,\n    and: typeof nameOrConfig === 'string' ? {name: nameOrConfig} : nameOrConfig,\n  }) as any\n\n  const node = createNode({\n    family: {type: DOMAIN},\n    regional: true,\n    parent: config?.domain || config?.parent,\n  })\n\n  const domain = {\n    history: {},\n    graphite: node,\n    hooks: {},\n  } as Domain\n\n  node.meta = initUnit(DOMAIN, domain, {\n    parent: config?.domain || config?.parent,\n    or: config,\n  })\n\n  forIn(\n    {\n      Event: createEvent,\n      Effect: createEffect,\n      Store: createStore,\n      Domain: createDomain,\n    },\n    (factory, tag) => {\n      const lowerCaseTag = tag.toLowerCase() as\n        | 'event'\n        | 'effect'\n        | 'store'\n        | 'domain'\n\n      const onCreateUnit = createNamedEvent(`on${tag}`)\n      domain.hooks[lowerCaseTag] = onCreateUnit\n\n      const history = new Set<any>()\n      domain.history[`${lowerCaseTag}s`] = history\n\n      onCreateUnit.create = unit => {\n        launch(onCreateUnit, unit)\n        return unit\n      }\n      add(\n        getGraph(onCreateUnit).seq,\n        calc((upd, _, stack) => {\n          stack.scope = null\n          return upd\n        }),\n      )\n      onCreateUnit.watch(unit => {\n        own(domain, [unit])\n        history.add(unit)\n        if (!unit.ownerSet) unit.ownerSet = history\n        if (!getParent(unit)) unit.parent = domain\n      })\n      own(domain, [onCreateUnit])\n\n      domain[`onCreate${tag}`] = (hook: (unit: any) => any) => {\n        forEach(history, hook)\n        return onCreateUnit.watch(hook)\n      }\n      domain[`create${tag}`] = domain[lowerCaseTag] = (\n        nameOrConfig: any,\n        rawConfig?: Config,\n      ) => {\n        const config = flattenConfig({and: rawConfig, or: nameOrConfig})\n        if (config?.domain) {\n          // @ts-expect-error complicated factory type\n          return factory(nameOrConfig, rawConfig)\n        }\n        // @ts-expect-error complicated factory type\n        return onCreateUnit(factory(nameOrConfig, {parent: domain, or: config}))\n      }\n    },\n  )\n\n  const parent = getParent(domain)\n  if (parent) {\n    forIn(domain.hooks, (from: NodeUnit, key) =>\n      createLinkNode(from, parent.hooks[key]),\n    )\n  }\n  if (config?.domain) {\n    config.domain.hooks.domain(domain)\n  }\n  return domain\n}\n","import {is} from '../is'\nimport {assert} from '../throw'\nimport type {Domain, ValuesMap, HandlersMap, Scope, Store} from '../unit.h'\nimport {normalizeValues} from './util'\nimport {createScope} from './createScope'\nimport {forEach} from '../collection'\n\ntype ForkConfig = {\n  values?: ValuesMap\n  handlers?: HandlersMap\n  scope?: Scope\n}\n\nexport function fork(\n  domainOrConfig?: Domain | ForkConfig,\n  optionalConfig?: ForkConfig,\n) {\n  let config: ForkConfig | void = domainOrConfig as any\n  let domain: Domain\n  if (is.domain(domainOrConfig)) {\n    domain = domainOrConfig\n    config = optionalConfig\n  }\n\n  const scope = createScope(domain!)\n\n  if (config) {\n    const oldScope = config.scope\n    if (oldScope) {\n      const activeEffects = oldScope.activeEffects\n      oldScope.activeEffects = []\n      scope.activeEffects = activeEffects\n      forEach(activeEffects, scopeRef => (scopeRef.ref = scope))\n    }\n    if (config.values) {\n      const {sidMap, unitMap, hasSidDoubles} = normalizeValues(config.values, unit =>\n        assert(is.store(unit), 'Values map can contain only stores as keys'),\n      )\n      Object.assign(scope.values.sidMap, sidMap)\n      forEach(unitMap, (value, unit) => {\n        scope.values.idMap[(unit as Store<any>).stateRef.id] = value\n      })\n      scope.fromSerialize =\n        !Array.isArray(config.values) && !(config.values instanceof Map)\n      scope.hasSidDoubles = hasSidDoubles\n    }\n    if (config.handlers) {\n      scope.handlers = normalizeValues(config.handlers, unit =>\n        assert(\n          is.effect(unit),\n          `Handlers map can contain only effects as keys`,\n        ),\n      )\n    }\n  }\n  return scope\n}\n","import {getForkPage, getGraph, getMeta, getParent} from '../getter'\nimport {setForkPage, getPageRef, currentPage} from '../kernel'\nimport {createNode} from '../createNode'\nimport {calc, compute} from '../step'\nimport type {Domain, Scope, SettledDefer, Store} from '../unit.h'\nimport type {StateRef} from '../index.h'\nimport {forEach} from '../collection'\nimport {DOMAIN, SAMPLER, SCOPE} from '../tag'\n\nexport function createScope(unit?: Domain): Scope {\n  const forkInFlightCounter = createNode({\n    scope: {\n      defers: [],\n      inFlight: 0,\n      fxID: 0,\n    },\n    node: [\n      calc((_, scope, stack) => {\n        if (!getParent(stack)) {\n          scope.fxID += 1\n          return\n        }\n        if (getMeta(getParent(stack).node, 'needFxCounter') === 'dec') {\n          scope.inFlight -= 1\n        } else {\n          scope.inFlight += 1\n          scope.fxID += 1\n        }\n      }),\n      compute({priority: SAMPLER, batch: true}),\n      calc(\n        (\n          _,\n          scope: {\n            inFlight: number\n            fxID: number\n            defers: SettledDefer[]\n          },\n        ) => {\n          const {defers, fxID} = scope\n          if (scope.inFlight > 0 || defers.length === 0) return\n          Promise.resolve().then(() => {\n            if (scope.fxID !== fxID) return\n            forEach(defers.splice(0, defers.length), defer => {\n              setForkPage(defer.parentFork)\n              defer.rs(defer.value)\n            })\n          })\n        },\n        false,\n        true,\n      ),\n    ],\n  })\n  const page = {} as Record<string, StateRef>\n  const storeChange = createNode({\n    node: [\n      calc((value, __, stack) => {\n        const storeStack = getParent(stack)\n        if (storeStack) {\n          const storeNode = storeStack.node\n          if (\n            !getMeta(storeNode, 'isCombine') ||\n            (getParent(storeStack) &&\n              getMeta(getParent(storeStack).node, 'op') !== 'combine')\n          ) {\n            const forkPage = getForkPage(stack)!\n            const id = storeNode.scope.state.id\n            const sid = getMeta(storeNode, 'sid')\n            forkPage.sidIdMap[sid] = id\n            forkPage.values.sidMap[sid] = value\n\n            const serialize = getMeta(storeNode, 'serialize')\n            if (serialize) {\n              if (serialize === 'ignore') {\n                forkPage.sidSerializeSettings.set(sid, {ignore: true})\n              } else {\n                forkPage.sidSerializeSettings.set(sid, {\n                  ignore: false,\n                  write: serialize.write,\n                })\n              }\n            }\n          }\n        }\n      }),\n    ],\n  })\n  const warnSerializeNode = createNode({\n    node: [\n      calc((_, __, stack) => {\n        const forkPage = getForkPage(stack)\n        if (forkPage) {\n          const storeStack = getParent(stack)\n          if (storeStack) {\n            const storeNode = storeStack.node\n            if (\n              !getMeta(storeNode, 'isCombine') ||\n              (getParent(storeStack) &&\n                getMeta(getParent(storeStack).node, 'op') !== 'combine')\n            ) {\n              forkPage.warnSerialize = true\n            }\n          }\n        }\n      }),\n    ],\n  })\n  const resultScope: Scope = {\n    cloneOf: unit,\n    reg: page,\n    values: {sidMap: {}, idMap: {}},\n    sidIdMap: {},\n    sidSerializeSettings: new Map(),\n    getState(store: StateRef | Store<any>) {\n      if ('current' in store) {\n        return getPageRef(currentPage, resultScope, null, store).current\n      }\n      const node = getGraph(store)\n      return getPageRef(currentPage, resultScope, node, node.scope.state, true)\n        .current\n    },\n    kind: SCOPE,\n    graphite: createNode({\n      family: {\n        type: DOMAIN,\n        links: [forkInFlightCounter, storeChange, warnSerializeNode],\n      },\n      meta: {unit: 'fork'},\n      scope: {forkInFlightCounter},\n    }),\n    additionalLinks: {},\n    handlers: {sidMap: {}, unitMap: new Map()},\n    fxCount: forkInFlightCounter,\n    storeChange,\n    warnSerializeNode,\n    activeEffects: [],\n  }\n  return resultScope\n}\n","import {observableSymbol} from './observable'\nimport type {Event} from './unit.h'\nimport {createEvent} from './createUnit'\nimport {assertObject} from './is'\nimport {assert} from './throw'\nimport {createSubscription} from './subscription'\n\nexport function fromObservable<T>(observable: any): Event<T> {\n  assertObject(observable)\n  const observableItem =\n    observableSymbol in observable ? observable[observableSymbol]() : observable\n  assert(observableItem.subscribe, 'expect observable to have .subscribe')\n  const event = createEvent<T>()\n  const disposer = createSubscription(event)\n  observableItem.subscribe({\n    next: event,\n    error: disposer,\n    complete: disposer,\n  })\n  return event\n}\n","import {processArgsToConfig} from './config'\nimport {validateSampleConfig, createSampling} from './sample'\n\nexport function guard(...args: any[]) {\n  let [[source, config], metadata] = processArgsToConfig(args)\n  if (!config) {\n    config = source\n    source = config.source\n  }\n  validateSampleConfig(config, 'guard')\n  return createSampling(\n    'guard',\n    config.clock,\n    source,\n    config.filter,\n    config.target,\n    null,\n    config.name,\n    metadata,\n    !config.greedy,\n    false,\n    true,\n  )\n}\n","import {is, isObject} from '../is'\nimport {assert} from '../throw'\nimport {launch} from '../kernel'\nimport type {Domain, Scope, ValuesMap, Store} from '../unit.h'\nimport type {Node} from '../index.h'\nimport {add, forEach, includes} from '../collection'\nimport {normalizeValues, traverseStores} from './util'\nimport {getGraph, getMeta} from '../getter'\n\n/**\n hydrate state on client\n\n const root = createDomain()\n hydrate(root, {\n  values: window.__initialState__\n})\n\n */\nexport function hydrate(domain: Domain | Scope, {values}: {values: ValuesMap}) {\n  assert(isObject(values), 'values property should be an object')\n  const {sidMap, unitMap} = normalizeValues(values)\n  const valuesSidList = Object.getOwnPropertyNames(sidMap)\n  const storesRefIdMap: Record<string, Store<any>> = {}\n  forEach(unitMap as unknown as Map<Store<any>, any>, (_, unit) => {\n    storesRefIdMap[unit.stateRef.id] = unit\n  })\n  // Array.from(unitMap.keys(),\n  const storeNodes: Node[] = []\n  const storeValues: any[] = []\n  let forkPage: Scope\n  let traverseTarget: Node\n  let needToAssign: true | void\n  if (is.scope(domain)) {\n    forkPage = domain\n    needToAssign = true\n    assert(forkPage.cloneOf, 'scope should be created from domain')\n    traverseTarget = getGraph(forkPage.cloneOf)\n  } else if (is.domain(domain)) {\n    traverseTarget = getGraph(domain)\n  } else {\n    assert(false, 'first argument of hydrate should be domain or scope')\n  }\n  traverseStores(\n    traverseTarget!,\n    (node, sid) => {\n      // forkPage.sidIdMap[sid] = node.scope.state.id\n      if (sid && includes(valuesSidList, sid)) {\n        add(storeNodes, node)\n        const serializer = getMeta(node, 'serialize')\n        if (serializer && serializer !== 'ignore') {\n          sidMap[sid] = serializer.read(sidMap[sid])\n        }\n        add(storeValues, sidMap[sid])\n      } else if (node.scope.state.id in storesRefIdMap) {\n        add(storeNodes, node)\n        add(storeValues, unitMap.get(storesRefIdMap[node.scope.state.id]))\n      }\n    },\n    true,\n  )\n  launch({\n    target: storeNodes,\n    params: storeValues,\n    scope: forkPage!,\n  })\n  if (needToAssign) {\n    Object.assign(forkPage!.values.sidMap, sidMap)\n  }\n}\n","import {createStore} from './createUnit'\nimport {is} from './is'\nimport {forIn} from './collection'\nimport {getParent} from './getter'\nimport {createLinkNode} from './forward'\nimport {deprecate} from './throw'\n\nexport function restore(obj: any, defaultState: any, config?: any) {\n  if (is.store(obj)) {\n    deprecate(false, 'restore($store)')\n    return obj\n  }\n  if (is.event(obj) || is.effect(obj)) {\n    const domain = getParent(obj)\n    const result = createStore(defaultState, {\n      parent: domain,\n      name: obj.shortName,\n      and: config,\n    })\n    createLinkNode(is.effect(obj) ? obj.doneData : obj, result)\n    if (domain) domain.hooks.store(result)\n    return result\n  }\n  const result: Record<string, any> = Array.isArray(obj) ? [] : {}\n  forIn(\n    obj,\n    (value, key) =>\n      (result[key] = is.store(value) ? value : createStore(value, {name: key})),\n  )\n  return result\n}\n","import {createDefer} from '../defer'\nimport {is} from '../is'\nimport {assert} from '../throw'\nimport {launch, forkPage} from '../kernel'\nimport type {Scope} from '../unit.h'\nimport type {Unit} from '../index.h'\n\n/** bind event to scope */\nexport function scopeBind(\n  unit: Unit,\n  {scope, safe}: {scope?: Scope; safe?: true} = {},\n) {\n  assert(\n    scope || forkPage || safe,\n    'scopeBind cannot be called outside of forked .watch',\n  )\n  const savedForkPage = scope || forkPage!\n  return is.effect(unit)\n    ? (params: any) => {\n        const req = createDefer()\n        launch({\n          target: unit,\n          params: {\n            params,\n            req,\n          },\n          scope: savedForkPage,\n        })\n        return req.req\n      }\n    : (params: any) => {\n        launch({target: unit, params, scope: savedForkPage})\n        return params\n      }\n}\n"],"names":["forIn","obj","cb","key","forEach","list","fn","assert","condition","message","Error","withRegion","unit","meta","getGraph","regionStack","id","parent","value","template","readTemplate","sidRoot","reportDeclaration","getParent","createNode","node","from","source","to","target","child","scope","family","familyRaw","type","regional","sources","arrifyNodes","links","owners","seq","item","add","result","nextNodeID","next","CROSSLINK","link","getOwners","owner","getLinks","own","getValue","launch","payload","upsert","pageForLaunch","currentPage","stackForLaunch","forkPageForLaunch","forkPage","params","defer","page","getForkPage","Array","isArray","i","length","pushFirstHeapItem","isRoot","stop","skip","reg","lastStartedState","isWatch","isPure","kernelLoop","deleteMin","idx","stack","hasPageReg","hasScopeReg","local","fail","stepn","step","order","priority","barrierID","fullID","barriers","has","pushHeap","delete","data","STACK","REG_A","VALUE","store","STORE","pageForRef","getPageForRef","initRefInScope","softRead","undefined","readRef","getPageRef","current","getMeta","pure","computationResult","safe","tryRun","filter","inspector","finalValue","nextNode","fxCount","storeChange","warnSerializeNode","additionalLinks","unitObjectName","objOrArr","method","name","comma","is","getCompositeName","fullName","toString","createName","path","shortName","composite","concat","processArgsToConfig","args","singleArgument","rawConfig","assertObject","metadata","or","childConfig","and","unwrappedNestedValue","isObject","nested","applyTemplate","handlers","createEvent","nameOrConfig","maybeConfig","config","flattenConfig","event","deprecate","oldPage","setCurrentPage","create","callCreate","finalEvent","Object","assign","graphite","initUnit","actualOp","EVENT","watch","watchUnit","map","deriveEvent","MAP","userFnCall","callStack","filterMap","calc","isVoid","prepend","contramapped","createLinkNode","applyParentHook","domain","hooks","setMeta","on","methodName","nodeSet","assertNodeSet","isFunction","trigger","off","getSubscribers","set","createSubscription","updateStore","callARegStack","createStore","defaultState","props","plainState","createStateRef","updates","named","derived","plainStateId","subscribers","Map","stateRef","getState","reachedPage","targetRef","setState","state","reset","units","currentSubscription","get","firstState","lastResult","storeState","innerStore","linkNode","callStackAReg","addRefOp","getStoreState","noInit","eventOrFn","subscription","updateFilter","defaultConfig","upd","_","b","read","a","mov","serializeMeta","ignored","sid","reinit","combine","handler","stores","structStoreShape","shapeReady","noArraySpread","rawHandler","slice","storeCombination","createDefer","req","Promise","rs","rj","catch","createEffect","instance","EFFECT","kind","use","runner","getCurrent","anyway","finally","done","status","error","doneData","failData","getType","scope_","scopeHandler","unitMap","sidMap","scopeRef","createScopeRef","onResolve","onSettled","onReject","ok","runFn","then","op","fx","fxID","nextEffectID","savedFork","setForkPage","inFlight","serialize","x","pending","amount","effect","merge","validateSampleConfig","atLeastOneFieldExists","sampleConfigFields","field","fieldErrorMessage","traverseStores","root","needSidlessStores","visit","includes","normalizeValues","values","assertEach","mapOrRecordValues","hasSidDoubles","callback","unsubscribe","observableSymbol","Symbol","observable","DOMAIN","SCOPE","SAMPLER","BARRIER","SAMPLE","graph","val","compositeName","removeItem","pos","indexOf","splice","push","subject","suggestion","console","idCount","reporter","nextUnitID","nextStepID","readSidRoot","ownerUnit","_link","flat","assertNodeSetItem","valueName","reason","assertTarget","targetField","cmd","batch","nextBarrierID","compute","run","isEffect","toStack","samplerPriority","isFilter","ref","before","heap","ret","v","getPriority","r","l","queue","ix","first","last","size","bucket","t","Set","newForkPage","newPage","isGetState","noopParser","sourceRef","isKernelCall","refsMap","_sourceRef$meta","parser","fromSerialize","idMap","sidIdMap","isFresh","needToAssign","err","failReason","part","removeFromNode","currentNode","targetNode","clearNodeNormalized","deep","isDomainUnit","pop","clearMap","clear","clearNode","ownerSet","history","events","effects","domains","scopeFn","hookType","isDomain","unitId","thru","subscribe","observer","nativeTemplate","mapped","caller","storeRef","reader","needSpread","clone","stateNew","rawShape","storeStateRef","rawShapeReader","softReader","c","childRef","defaultShape","activeEffects","sidechain","createSampling","clock","batched","targetMayBeStore","filterRequired","isUpward","sourceIsClock","filterType","clockState","filterNodes","filterRef","hasFilter","syncSourceState","readAndFilter","hasSource","jointNode","src","joint","isSourceStore","launchCase","scopeTargets","noopSerializer","start","ctx","reject","parentFork","defers","launchUnits","launchParams","injected","mapParams","attached","runnerSteps","runnerFnStep","computedParams","sourceData","isEffectHandler","parentDomain","setters","createDomain","Event","Effect","Store","Domain","factory","tag","lowerCaseTag","toLowerCase","onCreateUnit","createNamedEvent","hook","scopeLinks","domainOrConfig","optionalConfig","forkInFlightCounter","resolve","__","storeStack","storeNode","sidSerializeSettings","ignore","write","warnSerialize","resultScope","cloneOf","createScope","oldScope","opts","observableItem","disposer","complete","greedy","valuesSidList","getOwnPropertyNames","storesRefIdMap","traverseTarget","storeNodes","storeValues","serializer","savedForkPage","ignoredStores","serializeSettings","onlyChanges","newInspector","rawName","targets","METHOD","match","configForm","cases","matchIsUnit","matchIsFunction","matchIsShape","splitterSeq","caseNames","keys","String","lastValues","needBarrier","storeOrFn","updater","caseName","splitterNode","loc"],"mappings":"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"}